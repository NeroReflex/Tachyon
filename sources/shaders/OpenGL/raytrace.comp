#version 450 core

#define expOfTwoOfMaxGeometryElementsInCollection 3
#define expOfTwoOfMaxCollectionElementsInBLAS 5

const float PI = 3.14159265359;
const float infinity = (1.0) / 0.0;
const float minusInfinity = (-1.0) / 0.0;
const mat4 identityTransform = mat4(1);

// This gets adjusted on each call by the OpenGL core
layout(local_size_x = 48, local_size_y = 32, local_size_z = 1) in;

struct Geometry {
	vec4 signature;
	vec4 vertex1_or_sphere_center;
	vec4 vertex2_or_sphere_radius;
	vec4 vertex3_or_nothing;
};

struct GeometryCollection {
	Geometry geometry[1 << expOfTwoOfMaxGeometryElementsInCollection]; // geometry slots
};

struct AABB {
	vec4 position; // this is the point of the aabb with min x, y and z components
	vec4 dimensions; // this is the amount to be added to aabbVertex to obtain the point with max x, y and z in the aabb
};

struct NodeData {
	AABB aabb;
	uint left; // this can also be the content if right is zero
	uint right; // this is zero if the node is a leaf
};

struct BLAS {
	GeometryCollection collection[1 << expOfTwoOfMaxCollectionElementsInBLAS];
	
	NodeData tree[((1 << expOfTwoOfMaxCollectionElementsInBLAS) * 2) - 1];
};

layout(std430, binding = 0) buffer sceneBLAS {
	BLAS tlasBLAS[]; // This is the BLAS collection
};

layout(std430, binding = 1) buffer sceneTree {
	NodeData tlasTree[]; // This is the TLAS tree that reference the whole BLAS collection
};

layout(std430, binding = 2) buffer sceneModelMatrix {
	mat4 blasModelMatrix[]; // This is the ModelMatrix collection for BLAS, given an index i ModelMatrix[i] is the model matrix of the object represented by tlasBLAS[i]
};

layout(rgba32f, binding = 0) uniform image2D img_output; // Raytracing output texture

layout(location = 2) uniform uint shadingAlgorithm;

layout(location = 3) uniform vec3 mOrigin;
layout(location = 4) uniform vec3 mLowerLeftCorner;
layout(location = 5) uniform vec3 mHorizontal;
layout(location = 6) uniform vec3 mVertical;

layout(location = 7) uniform mat4 tlasViewMatrix;

layout(location = 8) uniform uint width; // Render target surface width
layout(location = 9) uniform uint height; // Render target surface height

/*************************************************************************************************************************
 *                                                  Algorithms                                                           *
 *************************************************************************************************************************/

struct RayGeometryIntersection {
	float dist;
	vec4 point;
	vec4 normal;
};

struct Ray {
	vec4 origin;
	vec4 direction;
};

// Empty geometry is a sphere with radius equals to 0.0 such geometry CANNOT be intersected
const Geometry emptyGeometry = Geometry(
	vec4(0, 0, 0, 0),
	vec4(0, 0, 0, 0),
	vec4(0, 0, 0, 0),
	vec4(0, 0, 0, 0)
);

const RayGeometryIntersection miss = RayGeometryIntersection(infinity, vec4(0, 0, 0, 1), vec4(0, 0, 0, 0));

bool isLeaf(const NodeData node) {
	return node.right == 0;
}

bool hasMissed(const RayGeometryIntersection test) {
	return isinf(test.dist) || isnan(test.dist);
}

vec3 rayPointAt(const Ray ray, const float coeff) {
	return vec3(ray.origin) + coeff * vec3(ray.direction);
}

vec3 applyShading(const RayGeometryIntersection isect, const uint algorithm) {
	if (algorithm == 0) { // hit or miss
		return hasMissed(isect) ? vec3(0,0,0) : vec3(1,1,1);
	} else if (algorithm == 1) {
		// Here the camera position is vec3(0, 0, 0) because all of this is in camera space
		return vec3(max(0, dot(isect.normal, normalize(/*mPosition*/ -isect.point))));
	}

	return vec3(0.5, 0.5, 0.5); // this is to get attention as this should never verify
}

vec3 getInvDirection(const Ray ray) {
	return 1.0/ray.direction.xyz;
}

AABB transformAABB(const AABB starting, const mat4 transformMatrix) {
	vec4 v[8] = {
		transformMatrix * vec4(starting.position.x, starting.position.y, starting.position.z, 1),
		transformMatrix * vec4(starting.position.x, starting.position.y, starting.position.z + starting.dimensions.z, 1),
		transformMatrix * vec4(starting.position.x, starting.position.y + starting.dimensions.y, starting.position.z, 1),
		transformMatrix * vec4(starting.position.x, starting.position.y + starting.dimensions.y, starting.position.z + starting.dimensions.z, 1),
		transformMatrix * vec4(starting.position.x + starting.dimensions.x, starting.position.y, starting.position.z, 1),
		transformMatrix * vec4(starting.position.x + starting.dimensions.x, starting.position.y, starting.position.z + starting.dimensions.z, 1),
		transformMatrix * vec4(starting.position.x + starting.dimensions.x, starting.position.y + starting.dimensions.y, starting.position.z, 1),
		transformMatrix * vec4(starting.position.x + starting.dimensions.x, starting.position.y + starting.dimensions.y, starting.position.z + starting.dimensions.z, 1),
	};

	float maxX = minusInfinity, maxY = minusInfinity, maxZ=minusInfinity, minX=infinity, minY=infinity, minZ=infinity;

	for (uint i = 0; i < 8; ++i) {
		maxX = (v[i].x > maxX) ? v[i].x : maxX;
		maxY = (v[i].y > maxY) ? v[i].y : maxY;
		maxZ = (v[i].z > maxZ) ? v[i].z : maxZ;
		minX = (v[i].x < minX) ? v[i].x : minX;
		minY = (v[i].y < minY) ? v[i].y : minY;
		minZ = (v[i].z < minZ) ? v[i].z : minZ;
	}

	return AABB(vec4(minX, minY, minZ, 1), vec4(maxX-minX, maxY-minY, maxZ-minZ, 0));
}

bool intersectAABB(const Ray ray, const AABB aabb, const mat4 transformMatrix) {
	AABB transformedAABB = /*(transformMatrix != identityTransform) ? */transformAABB(aabb, transformMatrix) /*: *this*/;

	float tmin, tmax, tymin, tymax, tzmin, tzmax;

	vec3 orig = ray.origin.xyz;
	vec3 invdir = getInvDirection(ray);

	vec3 bounds[2] = {
		transformedAABB.position.xyz,
		(transformedAABB.position.xyz) + (transformedAABB.dimensions.xyz)
	};

	const int[3] raySigns = int[3](
		(invdir.x < 0) ? 1 : 0,
		(invdir.y < 0) ? 1 : 0,
		(invdir.z < 0) ? 1 : 0
	);

	tmin = (bounds[raySigns[0]].x - orig.x) * invdir.x;
	tmax = (bounds[1 - raySigns[0]].x - orig.x) * invdir.x;
	tymin = (bounds[raySigns[1]].y - orig.y) * invdir.y;
	tymax = (bounds[1 - raySigns[1]].y - orig.y) * invdir.y;

	if ((tmin > tymax) || (tymin > tmax))
		return false;
	if (tymin > tmin)
		tmin = tymin;
	if (tymax < tmax)
		tmax = tymax;

	tzmin = (bounds[raySigns[2]].z - orig.z) * invdir.z;
	tzmax = (bounds[1 - raySigns[2]].z - orig.z) * invdir.z;

	if ((tmin > tzmax) || (tzmin > tmax))
		return false;
	if (tzmin > tmin)
		tmin = tzmin;
	if (tzmax < tmax)
		tmax = tzmax;

	return true;
}

RayGeometryIntersection intersectGeometry(const Ray ray, const Geometry geometry, const mat4 transformMatrix, const float minDistance, const float maxDistance) {
	if (geometry.signature.w == 0.0) { // test ray-sphere intersection
		const vec3 center = vec3(transformMatrix * geometry.vertex1_or_sphere_center);
		const float radius = geometry.vertex2_or_sphere_radius.x;

		if (radius == 0) return miss;

		const vec3 origin = vec3(ray.origin);
		const vec3 direction = vec3(ray.direction);

		vec3 oc = origin - center;
	
		const float a = dot(direction, direction);
		const float b = dot(oc, direction);
		const float c = dot(oc, oc) - radius * radius;
		const float discriminant = b * b - a * c;

		if (discriminant > 0.0) { // if delta > 0 then we have two intersections (one for each side of the sphere)
			const float squareRoot = sqrt(discriminant);

			// x0 and x1 are the distances to the origin of the ray
			float x0 = (-b - squareRoot) / a, x1 = (-b + squareRoot) / a;

			// Use x0 and x1 to calculate intersection points
			vec3 point_x0 = rayPointAt(ray, x0), point_x1 = rayPointAt(ray, x1); // so if I use that distance as a coefficient I obtain the intersection point
		
			// Use intersecting points to calculate the surface normal at that point
			vec3 normal_x0 = (point_x0 - center) / radius, normal_x1 = (point_x1 - center) / radius; // and the normal for a point p is (point - center)/radius

			// No valid intersection? return a miss.
			if (((x0 <= minDistance) || (x0 >= maxDistance)) && ((x1 <= minDistance) || (x1 >= maxDistance))) {
				return miss;
			}

			// Choose the closest intersection point
			return (((x0 > minDistance) && (x0 < maxDistance)) && (x0 <= x1)) || ((x1 <= minDistance) || (x1 >= maxDistance)) ?
				RayGeometryIntersection(x0, vec4(point_x0, 1), vec4(normal_x0, 0)) : RayGeometryIntersection(x1, vec4(point_x1, 1), vec4(normal_x1, 0));
		}
	} else if (geometry.signature.w == 1.0) { // test ray-triangle intersection

	}

	return miss;
}

RayGeometryIntersection intersectCollection(const Ray ray, const GeometryCollection collection, const mat4 transformMatrix, const float minDistance, const float maxDistance) {
	RayGeometryIntersection bestHit = miss;

	for (uint i = 0; i < collection.geometry.length(); ++i) {
		// Execute the ray-geometry intersection algorithm
		const RayGeometryIntersection currentIntersectionInfo = intersectGeometry(ray, collection.geometry[i], transformMatrix, minDistance, maxDistance);

		// Check if this is a better hit than the former one
		if (currentIntersectionInfo.dist < bestHit.dist) {
			bestHit = currentIntersectionInfo;
		}
	}

	return bestHit;
}

RayGeometryIntersection intersectBLAS_ByIndex(const Ray ray, const uint blasIndex, const mat4 ViewMatrix, const float minDistance, const float maxDistance) {
	// Adjust transformation matrix to consider the BLAS model matrix
	mat4 transformMatrix = ViewMatrix * blasModelMatrix[blasIndex];

	RayGeometryIntersection bestHit = miss;

	int currentDepth = 0;
	uint currentPath = 0;

	while ((currentDepth < 32) && (currentDepth >= 0)) {
		uint currentNodeIndex = 0;

		// This for cycles is used to reach the interesting node
		for (uint i = 0; i < currentDepth; ++i) {
			currentNodeIndex = ((currentPath & (1 << currentDepth)) == 0) ? tlasBLAS[blasIndex].tree[currentNodeIndex].left : tlasBLAS[blasIndex].tree[currentNodeIndex].left;
		}

		if ((!isLeaf(tlasBLAS[blasIndex].tree[currentNodeIndex])) && (intersectAABB(ray, tlasBLAS[blasIndex].tree[currentNodeIndex].aabb, transformMatrix))) {
			// Go one level deeper
			currentDepth += 1;
		} else {
			// This is a leaf that should be tested...
			if ((isLeaf(tlasBLAS[blasIndex].tree[currentNodeIndex])) && (intersectAABB(ray, tlasBLAS[blasIndex].tree[currentNodeIndex].aabb, transformMatrix))) {
				RayGeometryIntersection currentHit = intersectCollection(ray, tlasBLAS[blasIndex].collection[tlasBLAS[blasIndex].tree[currentNodeIndex].left], transformMatrix, minDistance, maxDistance);

				if (currentHit.dist < bestHit.dist) bestHit = currentHit;
			}

			// in either case: subtree discarded or visited leaf the algorithm should reduce the depth and change the path
			currentDepth -= 1;

			while (((currentPath & (1 << currentDepth)) == 1) && (currentDepth >= 0)) {
				//set the bit at currentDepth position to 0
				currentPath &= ~(1 << currentDepth);

				// and decrease currentDepth
				currentDepth -= 1;
			}

			if (currentDepth >= 0) {
				// set the bit at currentDepth position to 1 (the next visit will choose another path)
				currentPath |= (1 << currentDepth);
			} else {
				// the visited node was the very last one (the right-most) and the iteration should come to an end
				break;
			}
		}
	}

	return bestHit;
}

RayGeometryIntersection castRay(const Ray ray, const mat4 transformMatrix, const float minDistance, const float maxDistance) {
	RayGeometryIntersection bestHit = miss;

	int currentDepth = 0;
	uint currentPath = 0;

	while ((currentDepth < 32) && (currentDepth >= 0)) {
		uint currentNodeIndex = 0;

		// This for cycles is used to reach the interesting node
		for (uint i = 0; i < currentDepth; ++i) {
			currentNodeIndex = ((currentPath & (1 << currentDepth)) == 0) ? tlasTree[currentNodeIndex].left : tlasTree[currentNodeIndex].left;
		}

		if ((!isLeaf(tlasTree[currentNodeIndex])) && (intersectAABB(ray, tlasTree[currentNodeIndex].aabb, transformMatrix))) {
			// Go one level deeper
			currentDepth += 1;
		} else {
			// This is a leaf that should be tested...
			if ((isLeaf(tlasTree[currentNodeIndex])) && (intersectAABB(ray, tlasTree[currentNodeIndex].aabb, transformMatrix))) {
				RayGeometryIntersection currentHit = intersectBLAS_ByIndex(ray, tlasTree[currentNodeIndex].left, transformMatrix, minDistance, maxDistance);

				if (currentHit.dist < bestHit.dist) bestHit = currentHit;
			}

			// in either case: subtree discarded or visited leaf the algorithm should reduce the depth and change the path
			currentDepth -= 1;

			while (((currentPath & (1 << currentDepth)) == 1) && (currentDepth >= 0)) {
				//set the bit at currentDepth position to 0
				currentPath &= ~(1 << currentDepth);

				// and decrease currentDepth
				currentDepth -= 1;
			}

			if (currentDepth >= 0) {
				// set the bit at currentDepth position to 1 (the next visit will choose another path)
				currentPath |= (1 << currentDepth);
			} else {
				// the visited node was the very last one (the right-most) and the iteration should come to an end
				break;
			}
		}
	}

	return bestHit;
}

Ray generateCameraRay(float s, float t) {
	return Ray(vec4(mOrigin, 1), vec4(mLowerLeftCorner + s * mHorizontal + t * mVertical - mOrigin, 0));
}

void main() {
	// base pixel colour for image
	vec4 pixel = vec4(0, 0, 0, 0);
	// get index in global work group i.e x,y position
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

	// Avoid calculating useless pixels
	if ((gl_GlobalInvocationID.x >= width) || (gl_GlobalInvocationID.y >= height)) {
		return;
	}
	
	// Get UV cordinates of the output texture
	const float u = float(gl_GlobalInvocationID.x) / float(width);
	const float v = float(gl_GlobalInvocationID.y) / float(height);

	// Generate camera ray
	Ray cameraRay = generateCameraRay(u, v);

	pixel = vec4(applyShading(castRay(cameraRay, tlasViewMatrix, 0.001, 1000.0), shadingAlgorithm), 1.0);
  
	// output to a specific pixel in the image
	imageStore(img_output, pixel_coords, pixel);
}
