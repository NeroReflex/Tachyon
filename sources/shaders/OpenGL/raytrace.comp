#version 450

#define COMP_SIZE 32

#define expOfTwoOfMaxGeometryElementsInCollection 3
#define expOfTwoOfMaxCollectionElementsInBLAS 3
#define expOfTwoOfMaxBLASElementsInTLAS 3

// This gets adjusted on each call by the OpenGL core
layout(local_size_x = COMP_SIZE, local_size_y = COMP_SIZE, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform image2D img_output;

uniform uint width; // Render target surface width
uniform uint height; // Render target surface height

struct Geometry {
	float data[4];
};

struct GeometryCollection {
	Geometry geometry[1 << expOfTwoOfMaxGeometryElementsInCollection]; // geometry slots
};

struct NodeData {
	vec4 aabbVertex; // this is the point of the aabb with min x, y and z components
	vec4 aabbDimensions; // this is the amount to be added to aabbVertex to obtain the point with max x, y and z in the aabb
	uint left; // this can also be the content if right is zero
	uint right; // this is zero if the node is a leaf
};

struct BLAS {
	GeometryCollection collection[1 << expOfTwoOfMaxCollectionElementsInBLAS];
	
	NodeData tree[((1 << expOfTwoOfMaxCollectionElementsInBLAS) * 2) - 1];
	mat4x4 ModelMatrix;
};

struct TLAS {
	mat4x4 ViewMatrix;
	NodeData tree[((1 << expOfTwoOfMaxBLASElementsInTLAS) * 2) - 1];
	BLAS blas[1 << expOfTwoOfMaxBLASElementsInTLAS];
};

uniform TLAS tlas;

struct RayGeometryIntersection {
	float dist;
	vec3 point;
};

struct Ray {
	vec4 origin;
	vec4 direction;
};

const float PI = 3.14159265359;

uniform vec3 mOrigin;
uniform vec3 mLowerLeftCorner;
uniform vec3 mHorizontal;
uniform vec3 mVertical;

Ray generateCameraRay(float s, float t) {
	return Ray(vec4(mOrigin, 1), vec4(mLowerLeftCorner + s * mHorizontal + t * mVertical - mOrigin, 0));
}

void main() {
	// base pixel colour for image
	vec4 pixel = vec4(0, 0, 0, 0);
	// get index in global work group i.e x,y position
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

	// Avoid calculating useless pixels
	if ((gl_GlobalInvocationID.x >= width) || (gl_GlobalInvocationID.y >= height)) {
		return;
	}
	
	const float u = float(gl_GlobalInvocationID.x) / float(width);
	const float v = float(gl_GlobalInvocationID.y) / float(height);

	// Generate camera ray
	Ray cameraRay = generateCameraRay(u, v);
	
	// TODO: Remove this, here for debug
	pixel = vec4(cameraRay.direction.xyz, 1);
  
	// output to a specific pixel in the image
	imageStore(img_output, pixel_coords, pixel);
}