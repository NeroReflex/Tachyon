#version 450 core

/*
#define expOfTwo_maxModels 9
#define expOfTwo_maxGeometryOnCollection 3
// TODO: investigate why setting this to 3 or less makes the CS crash
#define expOfTwo_maxCollectionsForModel 12 
*/
#define expOfTwo_maxModels 2
#define expOfTwo_maxGeometryOnCollection 3
// TODO: investigate why setting this to 3 or less makes the CS crash
#define expOfTwo_maxCollectionsForModel 4

#define numberOfTreeElementsToContainExpOfTwoLeafs( expOfTwo ) ((1 << (expOfTwo+1))-1)

#define expOfTwo_numOfVec4OnGeometrySerialization 1

#if defined(RENDER) || defined(QUERY_INFO)
	#define TLAS_MEMORY_MODEL readonly
	#define TLAS_READONLY

	#define BLAS_MOEMORY_MODEL readonly
	#define BLAS_READONLY

	#define GEOMETRY_MEMORY_MODEL readonly
	#define GEOMETRY_READONLY

	#define MODELMATRIX_MEMORY_MODEL readonly
	#define MODELMATRIX_READONLY

#elif defined(TLAS_UPDATE)
	#define TLAS_MEMORY_MODEL coherent

	#define BLAS_MOEMORY_MODEL readonly
	#define BLAS_READONLY

	#define GEOMETRY_MEMORY_MODEL readonly
	#define GEOMETRY_READONLY

	#define MODELMATRIX_MEMORY_MODEL readonly
	#define MODELMATRIX_READONLY
#else
	#define TLAS_MEMORY_MODEL coherent
	#define BLAS_MOEMORY_MODEL coherent
	#define GEOMETRY_MEMORY_MODEL coherent
	#define MODELMATRIX_MEMORY_MODEL coherent
#endif

const float PI = 3.14159265359;
const float infinity = (1.0) / 0.0;
const float minusInfinity = (-1.0) / 0.0;
const mat4 identityTransform = mat4(1);
const mat4 emptyTransform = mat4(0);

#if !defined(QUERY_INFO)

layout(rgba32f, binding = 4) uniform writeonly image2D debugOutput;

/*************************************************************************************************************************
 *                                                  Algorithms                                                           *
 *************************************************************************************************************************/

/**
 * Swaps two numbers.
 *
 * @param a the first number
 * @param b the second number
 */
 void swap(inout float a, inout float b) {
	float temp = a;
	a = b;
	b = temp;
}

/**
 * Finds the minimum component on a vector.
 *
 * @param a the vector
 * @return the minimum component
 */
float min_component(vec3 a) {
	return min(min(a.x, a.y), a.z);
}

/**
 * Finds the maximum component on a vector.
 *
 * @param a the vector
 * @return the maximum component
 */
float max_component(vec3 a) {
	return max(max(a.x, a.y), a.z);
}

/**
 * Checks if the given number is even.
 *
 * @param n the number to check
 * @return TRUE iif the given number is even
 */
bool isEven(const in uint n) {
	return (n & 0x0001) == 0;
}

/**
 * Given a node of a binary tree with a fixed structure with index i,
 * returns true if the node is the root of the entire structure.
 * 
 * @param i the node index on the tree-array
 * @return TRUE iif the index is the root of the tree-array
 */
bool isRootNode(const in uint i) {
	return i == 0;
}

/**
 * Given a node of a binary tree with a fixed structure with index i,
 * returns the index of its parent node in the same fixed structure.
 *
 * @param i the node index on the tree-array
 * @return the parent node index on the tree-array 
 */
uint parentNode(const in uint i) {
	return (i - 1) / 2;
}

/**
 * Given a node of a binary tree with a fixed structure with index i,
 * returns the index of its left childer node in the same fixed structure.
 *
 * @param i the node index on the tree-array
 * @return the left childern node index on the tree-array 
 */
uint leftNode(const in uint i) {
	return (2 * i + 1);
}

/**
 * Given a node of a binary tree with a fixed structure with index i,
 * returns the index of its right childer node in the same fixed structure.
 *
 * @param i the node index on the tree-array
 * @return the right childern node index on the tree-array 
 */
uint rightNode(const in uint i) {
	return (2 * i + 2);
}

/*=======================================================================================================
  ===                                        Ray structure                                            ===
  =======================================================================================================*/

struct Ray {
	vec4 origin;
	vec4 direction;
};

vec3 rayPointAt(const in Ray ray, const in float coeff) {
	return vec3(ray.origin) + coeff * vec3(ray.direction);
}

vec3 getInvDirection(const in Ray ray) {
	vec3 ray_dir = ray.direction.xyz;
	ray_dir.x += (ray_dir.x >= 0) ? 0.001 : -0.001;
	ray_dir.y += (ray_dir.z >= 0) ? 0.001 : -0.001;
	ray_dir.z += (ray_dir.z >= 0) ? 0.001 : -0.001;

	return normalize(1.0/(ray_dir));
}

/*=======================================================================================================
  ===                                           Camera                                                ===
  =======================================================================================================*/

/**
 * This is the representation of a camera.
 */
struct Camera {
	/**
	 * This is the observing point.
	 */
	vec3 lookFrom;

	/**
	 * This is the observed normalized direction.
	 */
	vec3 lookAt;

	/**
	 * This is the up vector.
	 */
	vec3 up;

	/**
	 * This is the field of view angle in degrees.
	 */
	float fieldOfView;

	/**
	 * This is the aspect ratio: width:height.
	 */
	float aspect;
};

/**
 * Generate a camera ray given its UV coordinates on screen.
 *
 * @param cam the camera
 * @param s the U coordinate
 * @param t the V ccordinate
 * @return the camera ray (in world coordinates)
 */
Ray generateCameraRayFromCamera(const in Camera cam, const in float s, const in float t) {
	vec3 u, v, w;
	const float theta = cam.fieldOfView * PI / 180;
	const float half_height = tan(theta / 2.0);
	const float half_width = cam.aspect * half_height;
	w = normalize(cam.lookFrom - cam.lookAt);
	u = normalize(cross(cam.up, w));
	v = cross(w, u);
	const vec3 mLowerLeftCorner = cam.lookFrom - half_width * u - half_height * v - w;
	const vec3 mHorizontal = 2.0 * (u * half_width);
	const vec3 mVertical = 2.0 * (v * half_height);

	return Ray(vec4(cam.lookFrom, 1), vec4(normalize(mLowerLeftCorner + s * mHorizontal + t * mVertical - cam.lookFrom), 0));
}

Ray generateCameraRayFromScreenCoord(const vec3 lookFrom, const vec3 lowerLeftCorner, const vec3 horizontal, const vec3 vertical, float s, float t) {
	return Ray(vec4(lookFrom, 1), vec4(normalize(lowerLeftCorner + s * horizontal + t * vertical - lookFrom), 0));
}

/*=======================================================================================================
  ===                                    Geometry Structure                                           ===
  =======================================================================================================*/

/**
 * This represents a sphere.
 */
struct Geometry {
	vec3 center;

	float radius;
};

Geometry emptyGeometry = Geometry(vec3(0, 0, 0), 0.0);

/*=======================================================================================================
  ===                                    AABB Structure & Algo                                        ===
  =======================================================================================================*/

/**
 * This represents an Axis-Aligned Bounding Box.
 *
 *    +--------------+ < Max vertex (max x, y and z amongs all vertices)
 *   /|             /|
 *  / |            / |
 * *--+-----------*  |
 * |  |           |  | Depth
 * |  |           |  |
 * |  |           |  |
 * |  +-----------+--+
 * | /            | /
 * |/             |/ Width
 * *--------------*
 * ^    Length
 * Position vertex (minimum x, y and z amongs all vertices)
 */
struct AABB {
	/**
	 * This is the position vertex of the AABB.
	 *
	 * The used format is vec4(x, y, z, 1)
	 */
	vec4 position; // this is the point of the aabb with min x, y and z components
	
	/**
	 * This is the collection of AABB dimensions.
	 *
	 * The used format is vec4(Length, Depth, Width, 0)
	 * Note: fastest way to find the max vertex of the AABB: position+dimensions
	 */
	vec4 dimensions; // this is the amount to be added to aabbVertex to obtain the point with max x, y and z in the aabb
};

/**
 * Represents an empty AABB (that has no area nor volume).
 */
AABB emptyAABB = AABB(vec4(0, 0, 0, 1), vec4(0, 0, 0, 0));

/**
 * Check if the AABB is empty.
 *
 * @param aabb the AABB to be checked
 * @return TRUE iif the AABB is a point in space
 */
bool isEmpty(const in AABB aabb) {
	return (
		((aabb.dimensions.x == 0) || (aabb.dimensions.y == 0) || (aabb.dimensions.z == 0)) ||
		( isinf(aabb.dimensions.x) || isinf(aabb.dimensions.y) || isinf(aabb.dimensions.z) ) ||
		( isnan(aabb.dimensions.x) || isnan(aabb.dimensions.y) || isnan(aabb.dimensions.z) ) 
	);
}

/**
 * Calculate the area of the given AABB.
 *
 * @param aabb the AABB to use for area calculation
 * @return the area of the AABB
 */
float getAreaAABB(const in AABB aabb) {
	return 2 * ((aabb.dimensions.x * aabb.dimensions.z) + (aabb.dimensions.x * aabb.dimensions.y) + (aabb.dimensions.y * aabb.dimensions.z));
}

float SAH(const in AABB containedAABB, const in AABB containerAABB) {
	return getAreaAABB(containedAABB) / getAreaAABB(containerAABB);
}

/**
 * Apply a transform to the given AABB.
 *
 * @param starting the AABB transformation will be applied to
 * @param transformMatrix the transform to be applied to all vertices of the AABB, given as a 4x4 matrix
 * @return the transformed AABB
 */
AABB transformAABB(const in AABB b, const in mat4 transformMatrix) {
	vec4 v[8] = {
		transformMatrix * vec4(b.position.x                 , b.position.y                 , b.position.z                 , 1),
		transformMatrix * vec4(b.position.x                 , b.position.y                 , b.position.z + b.dimensions.z, 1),
		transformMatrix * vec4(b.position.x                 , b.position.y + b.dimensions.y, b.position.z                 , 1),
		transformMatrix * vec4(b.position.x                 , b.position.y + b.dimensions.y, b.position.z + b.dimensions.z, 1),
		transformMatrix * vec4(b.position.x + b.dimensions.x, b.position.y                 , b.position.z                 , 1),
		transformMatrix * vec4(b.position.x + b.dimensions.x, b.position.y                 , b.position.z + b.dimensions.z, 1),
		transformMatrix * vec4(b.position.x + b.dimensions.x, b.position.y + b.dimensions.y, b.position.z                 , 1),
		transformMatrix * vec4(b.position.x + b.dimensions.x, b.position.y + b.dimensions.y, b.position.z + b.dimensions.z, 1),
	};

	float maxX = v[0].x, maxY = v[0].y, maxZ=v[0].z, minX=v[0].x, minY=v[0].y, minZ=v[0].z;

	for (uint i = 1; i < 8; ++i) {
		maxX = (v[i].x > maxX) ? v[i].x : maxX;
		maxY = (v[i].y > maxY) ? v[i].y : maxY;
		maxZ = (v[i].z > maxZ) ? v[i].z : maxZ;
		minX = (v[i].x < minX) ? v[i].x : minX;
		minY = (v[i].y < minY) ? v[i].y : minY;
		minZ = (v[i].z < minZ) ? v[i].z : minZ;
	}

	return AABB(vec4(minX, minY, minZ, 1), vec4(maxX-minX, maxY-minY, maxZ-minZ, 0));
}

/**
 * Test intersaction of the given ray with the ginve AABB after applying a transformation to the AABB.
 *
 * @param ray the input ray
 * @param aabb the input AABB
 * @param transformMatrix the transformation to be applied to the input AABB
 * @return TRUE iif the ray intersects the transformed AABB
 */
bool intersectAABB(const in Ray ray, const in AABB aabb, const in mat4 transformMatrix) {
	AABB transformedAABB = transformAABB(aabb, transformMatrix);

	if (isEmpty(transformedAABB)) return false;

	const vec3 invRaydir = getInvDirection(ray);

	const vec3 t0 = ((transformedAABB.position).xyz - ray.origin.xyz)*invRaydir;
	const vec3 t1 = ((transformedAABB.position + transformedAABB.dimensions).xyz - ray.origin.xyz)*invRaydir;
	const vec3 tmin = min(t0,t1), tmax = max(t0,t1);
	return max_component(tmin) <= min_component(tmax);
}

/**
 * Create the union of two AABBs.
 *
 * @param aabb1 the first AABB
 * @param aabb2 the second AABB
 * @return the union of the two AABBs
 */
AABB joinAABBs(const in AABB aabb1, const in AABB aabb2) {
	if (isEmpty(aabb1)) return aabb2;
	if (isEmpty(aabb2)) return aabb1;

	vec4 vMin = vec4(
		min(aabb1.position.x, aabb2.position.x),
		min(aabb1.position.y, aabb2.position.y),
		min(aabb1.position.y, aabb2.position.y),
		1);

	vec4 vMax = vec4(
		max(aabb1.position.x + aabb1.dimensions.x, aabb2.position.x + aabb2.dimensions.x),
		max(aabb1.position.y + aabb1.dimensions.y, aabb2.position.y + aabb2.dimensions.y),
		max(aabb1.position.z + aabb1.dimensions.z, aabb2.position.z + aabb2.dimensions.z),
		1);

	return AABB(vMin, vMax - vMin);
}

AABB generateFromGeometry(const in Geometry geo) {
	if (geo.radius <= 0) return emptyAABB;

	const float diameter = 2 * geo.radius;
	return AABB(vec4(geo.center.x - geo.radius, geo.center.y - geo.radius , geo.center.z - geo.radius, 1), vec4(diameter, diameter, diameter, 0));
}

AABB expandAABBWithGeometry(const in AABB aabb, const in Geometry geo) {
	AABB geometryAABB = generateFromGeometry(geo);
	return joinAABBs(aabb, geometryAABB);
}

/*=======================================================================================================
  ===                                    BVH-Tree Structures                                          ===
  =======================================================================================================*/

/**
 * Check if the BLAS node at the given index is a leaf.
 *
 * @param index the node index on the linearized BVH-tree
 * @return TRUE iif the node is a leaf
 */
bool isBLASNodeLeaf_ByIndex(const in uint leafIndex) {
	return leafIndex >= ((1 << expOfTwo_maxCollectionsForModel) - 1);
}

/**
 * Check if the TLAS node at the given index is a leaf.
 *
 * @param index the node index on the linearized BVH-tree
 * @return TRUE iif the node is a leaf
 */
bool isTLASNodeLeaf_ByIndex(const in uint leafIndex) {
	return leafIndex >= ((1 << expOfTwo_maxModels) - 1);
}

/**
 * Get the index of a leaf element from the index of that leaf node.
 *
 * @param leafIndex the index used to access the leaf on the BLAS
 * @return the index of the geometry collection
 */
uint LeafFromBLASNode_ByIndex(const in uint leafIndex) {
	return leafIndex - ((1 << expOfTwo_maxCollectionsForModel) - 1);
}

/**
 * Get the index of a leaf element from the index of that leaf node.
 *
 * @param leafIndex the index used to access the leaf on the TLAS
 * @return the index of the BLAS
 */
uint LeafFromTLASNode_ByIndex(const in uint leafIndex) {
	return leafIndex - ((1 << expOfTwo_maxModels) - 1);
}

/**
 * Get the index of a leaf element from the index of that leaf node.
 *
 * @param leafIndex the index used to access the leaf on the TLAS
 * @return the index of the BLAS
 */
uint NodeFromBLASLeaf_ByLeafNumber(const in uint leafIndex) {
	return leafIndex + ((1 << expOfTwo_maxCollectionsForModel) - 1);
}

/**
 * Get the index of a leaf element from the index of that leaf node.
 *
 * @param leafIndex the index used to access the leaf on the TLAS
 * @return the index of the BLAS
 */
uint NodeFromTLASLeaf_ByLeafNumber(const in uint leafIndex) {
	return leafIndex + ((1 << expOfTwo_maxModels) - 1);
}

/*=======================================================================================================
  ===                                  Core SSBOs & Related Data                                      ===
  =======================================================================================================*/

layout(rgba32f, binding = 0) uniform TLAS_MEMORY_MODEL image1D tlas; // Raytracing Top-Level Acceleration Structure: X is the node index

layout(rgba32f, binding = 1) uniform BLAS_MOEMORY_MODEL image2D tlasBLAS; // This is the BLAS collection: X is the node index, Y is the referred BLAS

layout(rgba32f, binding = 2) uniform GEOMETRY_MEMORY_MODEL image3D globalGeometry; // This is the BLAS collection: X is the geometry index, Y is the referred geometry collection (BLAS leaf), Z is the referred BLAS

layout(rgba32f, binding = 3) uniform MODELMATRIX_MEMORY_MODEL image2D ModelMatrix; // This is the collection of Model Matrices for each BLAS

mat4 ReadModelMatrix_ByIndex(const in uint index) {
	return mat4(
		imageLoad(ModelMatrix, ivec2(0, index)),
		imageLoad(ModelMatrix, ivec2(1, index)),
		imageLoad(ModelMatrix, ivec2(2, index)),
		imageLoad(ModelMatrix, ivec2(3, index))
	);
}

#if !defined(MODELMATRIX_READONLY)
void WriteModelMatrix_ByIndex(const in uint index, const in mat4 matrix) {
	imageStore(ModelMatrix, ivec2(0, index), matrix[0]);
	imageStore(ModelMatrix, ivec2(1, index), matrix[1]);
	imageStore(ModelMatrix, ivec2(2, index), matrix[2]);
	imageStore(ModelMatrix, ivec2(3, index), matrix[3]);
}
#endif

Geometry ReadGeometry_ByIndexes(const in uint blasIndex, const in uint collectionIndex, const in uint indexOnCollection) {
	vec4 center = imageLoad(globalGeometry, ivec3((indexOnCollection * (1 << expOfTwo_numOfVec4OnGeometrySerialization)) + 0, collectionIndex, blasIndex));
	vec4 radius = imageLoad(globalGeometry, ivec3((indexOnCollection * (1 << expOfTwo_numOfVec4OnGeometrySerialization)) + 1, collectionIndex, blasIndex));

	return Geometry(center.xyz, radius.x);
}

#if !defined(GEOMETRY_READONLY)

/**
 * Update the geometry on the given BLAS, collection and relative position on the collection.
 *
 * Note: memory synchronization (memoryBarrierImage) must be performed by the caller!
 *
 * @param blasIndex the index of the BLAS
 * @param leafIndex the index of leaf on the given BLAS (corresponds to the index of geometry collection on the given BLAS)
 * @param indexOnCollection the index of the chosen collection that will be updated
 * @param geometry the geometry to be written
 */
void WriteGeometry_ByIndexes(const in uint blasIndex, const in uint leafIndex, const in uint indexOnCollection, const in Geometry geometry) {
	imageStore(globalGeometry, ivec3((indexOnCollection * (1 << expOfTwo_numOfVec4OnGeometrySerialization)) + 0, leafIndex, blasIndex), vec4(geometry.center, 1));
	imageStore(globalGeometry, ivec3((indexOnCollection * (1 << expOfTwo_numOfVec4OnGeometrySerialization)) + 1, leafIndex, blasIndex), vec4(geometry.radius, geometry.radius, geometry.radius, geometry.radius));
}
#endif

/**
 * Read the AABB on the given position.
 *
 * Note: memory synchronization (memoryBarrierImage) must be performed by the caller!
 *
 * @param blas the index of selected BLAS
 * @param index the position in the linearized tree
 * @return the AABB stored at the given index
 */
AABB ReadAABBFromBLAS_ByIndexes(const in uint blas, const in uint index) {
	return AABB(imageLoad(tlasBLAS, ivec2(2*index, blas)), imageLoad(tlasBLAS, ivec2(2*index+1, blas)));
}

#if !defined(BLAS_READONLY)
/**
 * Update the AABB at the given index with the provided AABB.
 *
 * Note: memory synchronization (memoryBarrierImage) must be performed by the caller!
 * 
 * @param blas the index of selected BLAS
 * @param index the position in the linearized tree
 * @param aabb the AABB to write
 */
void WriteAABBOnBLAS_ByIndexes(const in uint blas, const in uint index, const in AABB aabb) {
	imageStore(tlasBLAS, ivec2(2*index, blas), aabb.position);
	imageStore(tlasBLAS, ivec2(2*index+1, blas), aabb.dimensions);
}
#endif

/**
 * Check if the given BLAS is empty.
 *
 * Note: an empty BLAS has the ModelMatrix set to an empty transform.
 *
 * @param index the index of the BLAS to be tested
 * @return TRUE iif the BLAS is empty
 */
bool isEmptyBLAS_ByIndex(const in uint index) {
	return ReadModelMatrix_ByIndex(index) == emptyTransform;
}

/**
 * Read the AABB on the given position.
 *
 * Note: memory synchronization (memoryBarrierImage) must be performed by the caller!
 *
 * @param index the position in the linearized tree
 * @return the AABB stored at the given index
 */
AABB ReadAABBFromTLAS_ByIndex(const in uint index) {
	return AABB(imageLoad(tlas, 2*int(index)), imageLoad(tlas, 2*int(index)+1));
}

#if !defined(TLAS_READONLY)
/**
 * Update the AABB at the given index with the provided AABB.
 *
 * Note: memory synchronization (memoryBarrierImage) must be performed by the caller!
 * 
 * @param index the position in the linearized tree
 * @param aabb the AABB to write
 */
void WriteAABBOnTLAS_ByIndex(const in uint index, const in AABB aabb) {
	imageStore(tlas, 2*int(index), aabb.position);
	imageStore(tlas, 2*int(index)+1, aabb.dimensions);
}
#endif

AABB generateAABBFromGeometryOnBLASLeaf_ByBaseIndexOnGeometry(const in uint blasIndex, const in uint collectionIndex) {
	AABB bounding = emptyAABB;

	for (uint i = 0; i < (1 << expOfTwo_maxGeometryOnCollection); ++i) {
		bounding = expandAABBWithGeometry(bounding, ReadGeometry_ByIndexes(blasIndex, collectionIndex, i));
	}

	return bounding;
}

#if !defined(TLAS_READONLY)
void UpdateTLASFromLeafToRoot_ByIndex(const in uint indexOfLeafInTLAS) {
	uint indexOfLastUpdatedNodeInTLAS = NodeFromTLASLeaf_ByLeafNumber(indexOfLeafInTLAS);

	// On the leaf write the AABB aware of its associated Model Matrix
	WriteAABBOnTLAS_ByIndex(
		indexOfLastUpdatedNodeInTLAS,
		transformAABB(ReadAABBFromBLAS_ByIndexes(indexOfLeafInTLAS, 0), ReadModelMatrix_ByIndex(indexOfLeafInTLAS))
	);

	while (!isRootNode(indexOfLastUpdatedNodeInTLAS)) {
		memoryBarrierImage();

		// Target the parent node for update
		indexOfLastUpdatedNodeInTLAS = parentNode(indexOfLastUpdatedNodeInTLAS);

		// Update the current node with the two ModelMatrix-aware child nodes
		WriteAABBOnTLAS_ByIndex(
			indexOfLastUpdatedNodeInTLAS,
			joinAABBs(
				ReadAABBFromTLAS_ByIndex(leftNode(indexOfLastUpdatedNodeInTLAS)),
				ReadAABBFromTLAS_ByIndex(rightNode(indexOfLastUpdatedNodeInTLAS))
			)
		);
	}
}
#endif

/*=======================================================================================================
  ===                           Ray-Geometry Intersection (Rendering)                                 ===
  =======================================================================================================*/

struct RayGeometryIntersection {
	float dist;
	vec4 point;
	vec4 normal;
};

const RayGeometryIntersection miss = RayGeometryIntersection(infinity, vec4(0, 0, 0, 1), vec4(0, 0, 0, 0));

RayGeometryIntersection bestHit(const in RayGeometryIntersection isect1, const in RayGeometryIntersection isect2) {
	return (isect1.dist <= isect2.dist) ? isect1 : isect2;
}

RayGeometryIntersection intersectGeometry(const in Ray ray, const in Geometry geometry, const in mat4 transformMatrix, const in float minDistance, const in float maxDistance) {
	const vec3 center = vec3(transformMatrix * vec4(geometry.center, 1));
	const float radius = geometry.radius;

	if (radius == 0) return miss;

	const vec3 origin = vec3(ray.origin);
	const vec3 direction = vec3(ray.direction);

	vec3 oc = origin - center;
	
	const float a = dot(direction, direction);
	const float b = dot(oc, direction);
	const float c = dot(oc, oc) - radius * radius;
	const float discriminant = b * b - a * c;

	if (discriminant > 0.0) { // if delta > 0 then we have two intersections (one for each side of the sphere)
		const float squareRoot = sqrt(discriminant);

		// x0 and x1 are the distances to the origin of the ray
		float x0 = (-b - squareRoot) / a, x1 = (-b + squareRoot) / a;

		// Use x0 and x1 to calculate intersection points
		vec3 point_x0 = rayPointAt(ray, x0), point_x1 = rayPointAt(ray, x1); // so if I use that distance as a coefficient I obtain the intersection point
		
		// Use intersecting points to calculate the surface normal at that point
		vec3 normal_x0 = (point_x0 - center) / radius, normal_x1 = (point_x1 - center) / radius; // and the normal for a point p is (point - center)/radius

		// No valid intersection? return a miss.
		if (((x0 <= minDistance) || (x0 >= maxDistance)) && ((x1 <= minDistance) || (x1 >= maxDistance))) {
			return miss;
		}

		// Choose the closest intersection point
		return (((x0 > minDistance) && (x0 < maxDistance)) && (x0 <= x1)) || ((x1 <= minDistance) || (x1 >= maxDistance)) ?
			RayGeometryIntersection(x0, vec4(point_x0, 1), vec4(normal_x0, 0)) : RayGeometryIntersection(x1, vec4(point_x1, 1), vec4(normal_x1, 0));
	}
	
	return miss;
}

RayGeometryIntersection intersectCollection_ByIndexes(const in Ray ray, const in uint blasIndex, const in uint collectionIndex, const in mat4 transformMatrix, const in float minDistance, const in float maxDistance) {
	RayGeometryIntersection bestHitSoFar = intersectGeometry(ray, ReadGeometry_ByIndexes(blasIndex, collectionIndex, 0), transformMatrix, minDistance, maxDistance);

	for (uint i = 1; i < (1 << expOfTwo_maxGeometryOnCollection); ++i) {
		// Check if this is a better hit than the former one
		bestHitSoFar = bestHit(
			bestHitSoFar,
			intersectGeometry(ray, ReadGeometry_ByIndexes(blasIndex, collectionIndex, i), transformMatrix, minDistance, maxDistance) // Compare to the result of ray-geometry intersection algorithm
		);
	}

	return bestHitSoFar;
}

/**
 * Check if the ray has missed every geometry that has been tested against.
 *
 * @param test the ray-geometry intersection algorithm output
 * @return TRUE if the ray has missed all geometry
 */
bool hasMissed(const in RayGeometryIntersection test) {
	return isinf(test.dist) || isnan(test.dist);
}

RayGeometryIntersection intersectBLAS_ByIndex(const in Ray ray, const in uint blasIndex, const in float minDistance, const in float maxDistance) {
	// Adjust transformation matrix to consider the BLAS model matrix
	const mat4 ModelMatrix = ReadModelMatrix_ByIndex(blasIndex);

	RayGeometryIntersection bestHitSoFar = miss;
	
	int currentDepth = 0;
	uint currentPath = 0x0000;
	
	while ((currentDepth < (expOfTwo_maxCollectionsForModel + 1)) && (currentDepth >= 0)) {
		// This for cycles is used to reach the interesting node index (the result is in currentNodeIndex)
		uint currentNodeIndex = 0;
		for (uint i = 0; i < currentDepth; ++i) {
			currentNodeIndex = ((currentPath & (1 << currentDepth)) == 0) ? leftNode(currentNodeIndex) : rightNode(currentNodeIndex);
		}

		bool goDeeper = false;

		if (intersectAABB(ray, ReadAABBFromBLAS_ByIndexes(blasIndex, currentNodeIndex), ModelMatrix)) {
			//imageStore(debugOutput, ivec2(int(gl_GlobalInvocationID.x), int(gl_GlobalInvocationID.y)), vec4(0,0,1,1));
			if (isBLASNodeLeaf_ByIndex(currentNodeIndex)) {
				bestHitSoFar = bestHit( // Update the best hit so far by comparing...
					bestHitSoFar, // the bast hit so far
					intersectCollection_ByIndexes(ray, blasIndex, LeafFromBLASNode_ByIndex(currentNodeIndex), ModelMatrix, minDistance, maxDistance) // and the result of the ray-collection traverse
				);
			} else {
				// Go one level deeper
				goDeeper = true;
				currentDepth += 1;
			}
		}

		if (!goDeeper) {
			// in either case: subtree discarded or visited leaf the algorithm should reduce the depth and change the path
			currentDepth -= 1;

			while ((currentPath & (1 << currentDepth)) == 1) {
				//set the bit at currentDepth position to 0
				currentPath &= ~(1 << currentDepth);

				if (currentDepth == 0) return bestHitSoFar;
				
				// and decrease currentDepth
				currentDepth -= 1;
			}

			// set the bit at currentDepth position to 1 (the next visit will choose another path)
			currentPath |= (1 << currentDepth);
		}
	}
	
	return bestHitSoFar;
}

RayGeometryIntersection castRay(const in Ray ray, const in float minDistance, const in float maxDistance) {
	RayGeometryIntersection bestHitSoFar = miss;
	
	uint currentDepth = 0;
	uint currentPath = 0;
	
	// Traverse the entire TLAS to find the best intersection
	while (currentDepth <= expOfTwo_maxModels) {
		// This for cycles is used to reach the interesting node index (the result is in currentNodeIndex)
		uint currentNodeIndex = 0;
		for (uint i = 0; i < currentDepth; ++i) {
			currentNodeIndex = ((currentPath & (1 << currentDepth)) == 0) ? leftNode(currentNodeIndex) : rightNode(currentNodeIndex);
		}

		bool goDeeper = false;

		if (intersectAABB(ray, ReadAABBFromTLAS_ByIndex(currentNodeIndex), identityTransform)) {
			if (isTLASNodeLeaf_ByIndex(currentNodeIndex)) {
				bestHitSoFar = bestHit( // Update the best hit so far by comparing...
					bestHitSoFar, // the bast hit so far
					intersectBLAS_ByIndex(ray, LeafFromTLASNode_ByIndex(currentNodeIndex), minDistance, maxDistance) // and the result of the ray-BLAS traverse
				);
			} else {
				// Go one level deeper
				goDeeper = true;
				currentDepth += 1;
			}
		}

		if (!goDeeper) {
			// in either case: subtree discarded or visited leaf the algorithm should reduce the depth and change the path
			currentDepth -= 1;

			while ((currentPath & (1 << currentDepth)) == 1) {
				//set the bit at currentDepth position to 0
				currentPath &= ~(1 << currentDepth);

				if (currentDepth == 0) return bestHitSoFar;
				
				// and decrease currentDepth
				currentDepth -= 1;
			}

			// set the bit at currentDepth position to 1 (the next visit will choose another path)
			currentPath |= (1 << currentDepth);
		}
	}
	
	return bestHitSoFar;
}

#endif

/*=======================================================================================================
  ===                          Entry Points (main): one for each stage                                ===
  =======================================================================================================*/

#if defined(BVH_INSERT)
/*=======================================================================================================
  ===                                  BVH-Tree Construction                                          ===
  =======================================================================================================*/

struct InputGeometry {
	vec4 centroid_radius;
};

struct InputGeometryCollection {
	InputGeometry inputCollection[1 << expOfTwo_maxCollectionsForModel];
};

Geometry transformToGPURepresentation(const InputGeometry inGeometry) {
	Geometry outGeometry = Geometry(inGeometry.centroid_radius.xyz, inGeometry.centroid_radius.w);

	return outGeometry;
}

layout (location = 0) uniform uint targetBLAS;

layout(std430, binding = 3) buffer insertionGeometry {
	InputGeometryCollection geometryToInsert[]; // This is the collection of geometry to be organized on the BLAS
};

/*
layout(std430, binding = 4) buffer insertionGeometryMorton {
	uint mortonCode[]; // This is the BLAS collection
};
*/

// Expands a 10-bit integer into 30 bits
// by inserting 2 zeros after each bit.
uint expandBits(uint v)
{
    v = (v * 0x00010001u) & 0xFF0000FFu;
    v = (v * 0x00000101u) & 0x0F00F00Fu;
    v = (v * 0x00000011u) & 0xC30C30C3u;
    v = (v * 0x00000005u) & 0x49249249u;
    return v;
}

/**
 * Calculates a 30-bit Morton code for the given 3D point located within the unit cube [0,1].
 */
uint morton3D(const in vec3 point)
{
    const float x = min(max(point.x * 1024.0f, 0.0f), 1023.0f);
    const float y = min(max(point.y * 1024.0f, 0.0f), 1023.0f);
    const float z = min(max(point.z * 1024.0f, 0.0f), 1023.0f);
    const uint xx = expandBits(uint(point.x));
    const uint yy = expandBits(uint(point.y));
    const uint zz = expandBits(uint(point.z));
    return xx * 4 + yy * 2 + zz;
}

layout(local_size_x = 32, local_size_y = 48, local_size_z = 1) in;

/**
 * This is the entry point for the geometry insertion program.
 * The basic idea is that we want to insert the geometry on the final position
 * (gl_GlobalInvocationID.y * (1 << expOfTwo_maxGeometryOnCollection)) + gl_GlobalInvocationID.x
 * and then build the tree back to the root.
 * 
 * Usage: the compute shader MUST be dispatched as glDispatchCompute(numOfGeometryPerCollection, numOfGeometryCollectionsPerBLAS, 1),
 *        also the geometry must be aligned with mortoncodes such as mortonCode[i] is the morton code of the geometry at geometry[i]
 */
void main() {
	if ((gl_GlobalInvocationID.y >= (1 << expOfTwo_maxCollectionsForModel)) || (gl_GlobalInvocationID.x >= (1 << expOfTwo_maxGeometryOnCollection))) return;

	// Copy the geometry on the final destination.
	WriteGeometry_ByIndexes(
		targetBLAS, gl_GlobalInvocationID.y,
		gl_GlobalInvocationID.x,
		transformToGPURepresentation(geometryToInsert[gl_GlobalInvocationID.y].inputCollection[gl_GlobalInvocationID.x])
	);

	// Wait for all geometry to be in-place
	memoryBarrierImage();
	//barrier();

	// the geometry has been updated
	//if (gl_GlobalInvocationID.x != 0) return;

	uint indexOfNodeInBLASToUpdate = NodeFromBLASLeaf_ByLeafNumber(gl_GlobalInvocationID.y);
	WriteAABBOnBLAS_ByIndexes(targetBLAS, indexOfNodeInBLASToUpdate, generateAABBFromGeometryOnBLASLeaf_ByBaseIndexOnGeometry(targetBLAS, gl_GlobalInvocationID.y));
	
	while (!isRootNode(indexOfNodeInBLASToUpdate)) {
		memoryBarrierImage();

		indexOfNodeInBLASToUpdate = parentNode(indexOfNodeInBLASToUpdate);

		WriteAABBOnBLAS_ByIndexes(
			targetBLAS,
			indexOfNodeInBLASToUpdate,
			joinAABBs(
				ReadAABBFromBLAS_ByIndexes(targetBLAS, leftNode(indexOfNodeInBLASToUpdate)),
				ReadAABBFromBLAS_ByIndexes(targetBLAS, rightNode(indexOfNodeInBLASToUpdate))
			)
		);
	}

	// At the very end, flag the BLAS as used/occupied
	WriteModelMatrix_ByIndex(targetBLAS, identityTransform);

	// Perform a TLAS update after everything has been written on BLAS and geometry data collection
	barrier();
	if ((gl_GlobalInvocationID.x == 0) && (gl_GlobalInvocationID.y == 0) && (gl_GlobalInvocationID.z == 0)) {
		UpdateTLASFromLeafToRoot_ByIndex(targetBLAS);
	}
}

#elif defined(TLAS_FLUSH)

layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

/**
 * This is the entry point for the TLAS nuke program.
 * The basic idea is that we want to empty all geometry and then (re-)build the tree back to the root.
 *
 * Usage: the compute shader MUST be dispatched as glDispatchCompute(maxModels, 1, 1).
 */
void main() {
	// An instance of this compute shader will reset the BLAS at index gl_GlobalInvocationID.x
	if ((gl_GlobalInvocationID.x < (1 << expOfTwo_maxModels)) && (gl_GlobalInvocationID.y == 0) && (gl_GlobalInvocationID.z == 0)) {
		const uint indexOfBLASToNuke = gl_GlobalInvocationID.x;

		WriteModelMatrix_ByIndex(indexOfBLASToNuke, emptyTransform);
	
		uint indexOfNodeInTLAS = NodeFromTLASLeaf_ByLeafNumber(indexOfBLASToNuke);

		WriteAABBOnTLAS_ByIndex(indexOfNodeInTLAS, emptyAABB);

		// This update the TLAS from a leaf to its root
		while (!isRootNode(indexOfNodeInTLAS)) {
			memoryBarrierImage();

			indexOfNodeInTLAS = parentNode(indexOfNodeInTLAS);

			WriteAABBOnTLAS_ByIndex(indexOfNodeInTLAS, emptyAABB);
		}

		// This nuke the entire BLAS
		for (uint blasLinearNode = 0; blasLinearNode < ( numberOfTreeElementsToContainExpOfTwoLeafs(expOfTwo_maxModels) ); ++blasLinearNode) {
			WriteAABBOnBLAS_ByIndexes(indexOfBLASToNuke, blasLinearNode, emptyAABB);

			memoryBarrierImage();
		}

		for (uint geometryCollectionIndex = 0; geometryCollectionIndex < (1 << expOfTwo_maxCollectionsForModel); ++geometryCollectionIndex) {
			for (uint geometryIndex = 0; geometryIndex < (1 << expOfTwo_maxGeometryOnCollection); ++geometryIndex) {
				WriteGeometry_ByIndexes(indexOfBLASToNuke, geometryCollectionIndex, geometryIndex, emptyGeometry);

				memoryBarrierImage();
			}
		}

	}
}

#elif defined(TLAS_UPDATE)

layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

/**
 * This is the entry point for the TLAS update program.
 * The basic idea is that we want the AABB of each leaf on the TLAS to be the AABB of the root
 * of the corresponding BLAS, but transformated accordingly to the ModelMatrix.
 *
 * Usage: the compute shader MUST be dispatched as glDispatchCompute(maxModels, 1, 1).
 */
void main () {
	// If this work doen't map to a BLAS do nothing
	if ((gl_GlobalInvocationID.x >= (1 << expOfTwo_maxModels)) || (gl_GlobalInvocationID.y != 0) || (gl_GlobalInvocationID.z != 0)) return;
	
	UpdateTLASFromLeafToRoot_ByIndex(gl_GlobalInvocationID.x);
}

#elif defined(QUERY_INFO)

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout (std430, binding = 1) writeonly buffer raytracerInfo {
	uint expOfTwo_numberOfModels;
	uint expOfTwo_numberOfGeometryCollectionOnBLAS;
	uint expOfTwo_numberOfGeometryOnCollection;

	// Geometry is stored as consecutive vec4 in a texture, on the x axis.
	uint oxpOfTwo_numberOfTesselsForGeometryTexturazation; // This number is the number of texture texels used to store the texture
};

/**
 * This is the entry point used to query information about the raytracer.
 *
 * Usage: the compute shader MUST be dispatched as glDispatchCompute(1, 1, 1)
 */
void main() {
	// Only one instance is necessary
	if ((gl_GlobalInvocationID.x != 0) || (gl_GlobalInvocationID.y != 0) || (gl_GlobalInvocationID.z != 0)) return;

	expOfTwo_numberOfModels = expOfTwo_maxModels;
	expOfTwo_numberOfGeometryCollectionOnBLAS = expOfTwo_maxCollectionsForModel;
	expOfTwo_numberOfGeometryOnCollection = expOfTwo_maxGeometryOnCollection;

	oxpOfTwo_numberOfTesselsForGeometryTexturazation = expOfTwo_numOfVec4OnGeometrySerialization;
}

#elif defined(RENDER)

layout(local_size_x = 32, local_size_y = 48, local_size_z = 1) in;

layout(rgba32f, binding = 5) uniform writeonly image2D renderTarget; // Raytracing output texture

layout (location = 0) uniform uint width;
layout (location = 1) uniform uint height;

layout (location = 2) uniform vec3 cameraPosition;
layout (location = 3) uniform vec3 cameraViewDir;
layout (location = 4) uniform vec3 cameraUpVector;
layout (location = 5) uniform float cameraFoV;
layout (location = 6) uniform float cameraAspect;

layout(location = 7) uniform vec3 cameraLowerLeftCorner;
layout(location = 8) uniform vec3 cameraHorizontal;
layout(location = 9) uniform vec3 cameraVertical;

/**
 * This is the entry point for the rendering program.
 *
 * Usage: the compute shader MUST be dispatched as glDispatchCompute(width, height, 1).
 */
void main () {
	// Avoid calculating useless pixels
	if ((gl_GlobalInvocationID.x >= width) || (gl_GlobalInvocationID.y >= height)) return;

	// base pixel color for image
	vec4 pixel = vec4(0, 0, 0, 0);

	// get index in global work group i.e x,y position
	const ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

	// Get UV cordinates of the output texture
	const float u = float(gl_GlobalInvocationID.x) / float(width);
	const float v = float(gl_GlobalInvocationID.y) / float(height);

	// Generate camera
	const Camera camera = Camera(cameraPosition, cameraViewDir, cameraUpVector, cameraFoV, cameraAspect);

	// Generate camera ray
	//const Ray cameraRay = generateCameraRay(camera, u, v);
	const Ray cameraRay = generateCameraRayFromScreenCoord(camera.lookFrom, cameraLowerLeftCorner, cameraHorizontal, cameraVertical, u, v);

	//RayGeometryIntersection isect = castRay(cameraRay, 0.001, 1000.0); // Cast a ray on the TLAS and check for hit

	/* // With this code the horizontal artifact is not shown
	RayGeometryIntersection isect = miss;
	isect = bestHit(isect, intersectGeometry(cameraRay, ReadGeometry_ByIndexes(0, 0, 0), ReadModelMatrix_ByIndex(0), 0.001, 10000.00 ));
	isect = bestHit(isect, intersectGeometry(cameraRay, ReadGeometry_ByIndexes(0, 0, 1), ReadModelMatrix_ByIndex(0), 0.001, 10000.00 ));
	isect = bestHit(isect, intersectGeometry(cameraRay, ReadGeometry_ByIndexes(0, 0, 2), ReadModelMatrix_ByIndex(0), 0.001, 10000.00 ));
	isect = bestHit(isect, intersectGeometry(cameraRay, ReadGeometry_ByIndexes(0, 0, 3), ReadModelMatrix_ByIndex(0), 0.001, 10000.00 ));
	*/

	// debugging output texture
	//imageStore(debugOutput, pixel_coords, vec4(getInvDirection(cameraRay), 1));

	if (intersectAABB(cameraRay, ReadAABBFromBLAS_ByIndexes(0, 0), ReadModelMatrix_ByIndex(0))) {
		imageStore(debugOutput, pixel_coords, vec4(1, 0, 0, 1));
	} else {
		imageStore(debugOutput, pixel_coords, vec4(0, 0, 1, 1));
	}

	RayGeometryIntersection isect = intersectBLAS_ByIndex(cameraRay, 0, 0.001, 10000);

	pixel = vec4( vec3(max(0, dot(isect.normal, normalize(vec4(camera.lookFrom, 0) - isect.point)))) , 1.0);
  
	// output to a specific pixel in the image
	imageStore(renderTarget, pixel_coords, pixel);
}



#endif
