#version 450 core

#define expOfTwo_maxModels 10
#define expOfTwo_maxGeometryOnCollection 3
#define expOfTwo_maxCollectionsForModel 15

#define expOfTwo_numberOfLeafsOnBLAS (expOfTwo_maxCollectionsForModel-expOfTwo_maxGeometryOnCollection)
#define expOfTwo_numberOfLeafsOnTLAS (expOfTwo_maxModels)

#define numberOfTreeElementsToContainExpOfTwoLeafs( expOfTwo ) ((1 << (expOfTwo+1))-1)

const float PI = 3.14159265359;
const float infinity = (1.0) / 0.0;
const float minusInfinity = (-1.0) / 0.0;
const mat4 identityTransform = mat4(1);
const mat4 emptyTransform = mat4(0);

/*************************************************************************************************************************
 *                                                  Algorithms                                                           *
 *************************************************************************************************************************/

bool isEven(uint n) {
	return (n & 0x0001) == 0;
}

/**
 * Given a node of a binary tree with a fixed structure with index i,
 * returns true if the node is the root of the entire structure.
 * 
 * @param i the node index on the tree-array
 * @return TRUE iif the index is the root of the tree-array
 */
bool isRootNode(uint i) {
	return i == 0;
}

/**
 * Given a node of a binary tree with a fixed structure with index i,
 * returns the index of its parent node in the same fixed structure.
 *
 * @param i the node index on the tree-array
 * @return the parent node index on the tree-array 
 */
uint parentNode(uint i) {
	return (i - 1) / 2;
}

/**
 * Given a node of a binary tree with a fixed structure with index i,
 * returns the index of its left childer node in the same fixed structure.
 *
 * @param i the node index on the tree-array
 * @return the left childern node index on the tree-array 
 */
uint leftNode(uint i) {
	return (2 * i + 1);
}

/**
 * Given a node of a binary tree with a fixed structure with index i,
 * returns the index of its right childer node in the same fixed structure.
 *
 * @param i the node index on the tree-array
 * @return the right childern node index on the tree-array 
 */
uint rightNode(uint i) {
	return (2 * i + 2);
}

/*=======================================================================================================
  ===                                        Ray structure                                            ===
  =======================================================================================================*/

struct Ray {
	vec4 origin;
	vec4 direction;
};

vec3 rayPointAt(const Ray ray, const float coeff) {
	return vec3(ray.origin) + coeff * vec3(ray.direction);
}

vec3 getInvDirection(const Ray ray) {
	return 1.0/ray.direction.xyz;
}

/*=======================================================================================================
  ===                                           Camera                                                ===
  =======================================================================================================*/

/**
 * This is the representation of a camera.
 */
struct Camera {
	/**
	 * This is the observing point.
	 */
	vec3 lookFrom;

	/**
	 * This is the observed normalized direction.
	 */
	vec3 lookAt;

	/**
	 * This is the up vector.
	 */
	vec3 up;

	/**
	 * This is the field of view angle in degrees.
	 */
	float fieldOfView;

	/**
	 * This is the aspect ratio: width:height.
	 */
	float aspect;
};

/**
 * Generate a camera ray given its UV coordinates on screen.
 *
 * @param cam the camera
 * @param s the U coordinate
 * @param t the V ccordinate
 * @return the camera ray (in world coordinates)
 */
Ray generateCameraRay(Camera cam, float s, float t) {
	vec3 u, v, w;
	const float theta = cam.fieldOfView * PI / 180;
	const float half_height = tan(theta / 2.0);
	const float half_width = cam.aspect * half_height;
	w = normalize(cam.lookFrom - cam.lookAt);
	u = normalize(cross(cam.up, w));
	v = cross(w, u);
	const vec3 mLowerLeftCorner = cam.lookFrom - half_width * u - half_height * v - w;
	const vec3 mHorizontal = 2.0 * (u * half_width);
	const vec3 mVertical = 2.0 * (v * half_height);

	return Ray(vec4(cam.lookFrom, 1), vec4(normalize(mLowerLeftCorner + s * mHorizontal + t * mVertical - cam.lookFrom), 0));
}

/*=======================================================================================================
  ===                                    Geometry Structure                                           ===
  =======================================================================================================*/

/**
 * This represents a sphere.
 */
struct Geometry {
	vec4 center;

	float radius;
};

Geometry emptyGeometry = Geometry(vec4(0, 0, 0, 1), 0.0);

/*=======================================================================================================
  ===                                    AABB Structure & Algo                                        ===
  =======================================================================================================*/

/**
 * This represents an Axis-Aligned Bounding Box.
 *
 *    +--------------+ < Max vertex (max x, y and z amongs all vertices)
 *   /|             /|
 *  / |            / |
 * *--+-----------*  |
 * |  |           |  | Depth
 * |  |           |  |
 * |  |           |  |
 * |  +-----------+--+
 * | /            | /
 * |/             |/ Width
 * *--------------*
 * ^    Length
 * Position vertex (minimum x, y and z amongs all vertices)
 */
struct AABB {
	/**
	 * This is the position vertex of the AABB.
	 *
	 * The used format is vec4(x, y, z, 1)
	 */
	vec4 position; // this is the point of the aabb with min x, y and z components
	
	/**
	 * This is the collection of AABB dimensions.
	 *
	 * The used format is vec4(Length, Depth, Width, 0)
	 * Note: fastest way to find the max vertex of the AABB: position+dimensions
	 */
	vec4 dimensions; // this is the amount to be added to aabbVertex to obtain the point with max x, y and z in the aabb
};

/**
 * Represents an empty AABB (that has no area nor volume).
 */
AABB emptyAABB = AABB(vec4(0, 0, 0, 1), vec4(0, 0, 0, 0));

/**
 * Check if the AABB is empty.
 *
 * @param aabb the AABB to be checked
 * @return TRUE iif the AABB is a point in space
 */
bool isEmpty(const AABB aabb) {
	return aabb.dimensions == vec4(0, 0, 0, 0);
}

/**
 * Calculate the area of the given AABB.
 *
 * @param aabb the AABB to use for area calculation
 * @return the area of the AABB
 */
float getAreaAABB(const AABB aabb) {
	return 2 * ((aabb.dimensions.x * aabb.dimensions.z) + (aabb.dimensions.x * aabb.dimensions.y) + (aabb.dimensions.y * aabb.dimensions.z));
}

float SAH(const AABB containedAABB, const AABB containerAABB) {
	return getAreaAABB(containedAABB) / getAreaAABB(containerAABB);
}

/**
 * Apply a transform to the given AABB.
 *
 * @param starting the AABB transformation will be applied to
 * @param transformMatrix the transform to be applied to all vertices of the AABB, given as a 4x4 matrix
 * @return thetransformed AABB
 */
AABB transformAABB(const AABB starting, const mat4 transformMatrix) {
	vec4 v[8] = {
		transformMatrix * vec4(starting.position.x, starting.position.y, starting.position.z, 1),
		transformMatrix * vec4(starting.position.x, starting.position.y, starting.position.z + starting.dimensions.z, 1),
		transformMatrix * vec4(starting.position.x, starting.position.y + starting.dimensions.y, starting.position.z, 1),
		transformMatrix * vec4(starting.position.x, starting.position.y + starting.dimensions.y, starting.position.z + starting.dimensions.z, 1),
		transformMatrix * vec4(starting.position.x + starting.dimensions.x, starting.position.y, starting.position.z, 1),
		transformMatrix * vec4(starting.position.x + starting.dimensions.x, starting.position.y, starting.position.z + starting.dimensions.z, 1),
		transformMatrix * vec4(starting.position.x + starting.dimensions.x, starting.position.y + starting.dimensions.y, starting.position.z, 1),
		transformMatrix * vec4(starting.position.x + starting.dimensions.x, starting.position.y + starting.dimensions.y, starting.position.z + starting.dimensions.z, 1),
	};

	float maxX = minusInfinity, maxY = minusInfinity, maxZ=minusInfinity, minX=infinity, minY=infinity, minZ=infinity;

	for (uint i = 0; i < 8; ++i) {
		maxX = (v[i].x > maxX) ? v[i].x : maxX;
		maxY = (v[i].y > maxY) ? v[i].y : maxY;
		maxZ = (v[i].z > maxZ) ? v[i].z : maxZ;
		minX = (v[i].x < minX) ? v[i].x : minX;
		minY = (v[i].y < minY) ? v[i].y : minY;
		minZ = (v[i].z < minZ) ? v[i].z : minZ;
	}

	return AABB(vec4(minX, minY, minZ, 1), vec4(maxX-minX, maxY-minY, maxZ-minZ, 0));
}


bool intersectAABB(const Ray ray, const AABB aabb, const mat4 transformMatrix) {
	AABB transformedAABB = transformAABB(aabb, transformMatrix);

	if (isEmpty(transformedAABB)) return false;

	float tmin, tmax, tymin, tymax, tzmin, tzmax;

	vec3 orig = ray.origin.xyz;
	vec3 invdir = getInvDirection(ray);

	vec3 bounds[2] = {
		transformedAABB.position.xyz,
		(transformedAABB.position.xyz) + (transformedAABB.dimensions.xyz)
	};

	const int[3] raySigns = int[3](
		(invdir.x < 0) ? 1 : 0,
		(invdir.y < 0) ? 1 : 0,
		(invdir.z < 0) ? 1 : 0
	);

	tmin = (bounds[raySigns[0]].x - orig.x) * invdir.x;
	tmax = (bounds[1 - raySigns[0]].x - orig.x) * invdir.x;
	tymin = (bounds[raySigns[1]].y - orig.y) * invdir.y;
	tymax = (bounds[1 - raySigns[1]].y - orig.y) * invdir.y;

	if ((tmin > tymax) || (tymin > tmax))
		return false;
	if (tymin > tmin)
		tmin = tymin;
	if (tymax < tmax)
		tmax = tymax;

	tzmin = (bounds[raySigns[2]].z - orig.z) * invdir.z;
	tzmax = (bounds[1 - raySigns[2]].z - orig.z) * invdir.z;

	if ((tmin > tzmax) || (tzmin > tmax))
		return false;
	if (tzmin > tmin)
		tmin = tzmin;
	if (tzmax < tmax)
		tmax = tzmax;

	return true;
}

/**
 * Create the union of two AABBs.
 *
 * @param aabb1 the first AABB
 * @param aabb2 the second AABB
 * @return the union of the two AABBs
 */
AABB joinAABBs(const AABB aabb1, const AABB aabb2) {
	if (isEmpty(aabb1)) return aabb2;
	if (isEmpty(aabb2)) return aabb1;

	vec4 vMin = vec4(
		min(aabb1.position.x, aabb2.position.x),
		min(aabb1.position.y, aabb2.position.y),
		min(aabb1.position.y, aabb2.position.y),
		1);

	vec4 vMax = vec4(
		max(aabb1.position.x + aabb1.dimensions.x, aabb2.position.x + aabb2.dimensions.x),
		max(aabb1.position.y + aabb1.dimensions.y, aabb2.position.y + aabb2.dimensions.y),
		max(aabb1.position.z + aabb1.dimensions.z, aabb2.position.z + aabb2.dimensions.z),
		1);

	return AABB(vMin, vMax - vMin);
}

AABB generateFromGeometry(const Geometry geo) {
	float diameter = 2 * geo.radius;
	return AABB(vec4(geo.center.x - geo.radius, geo.center.y - geo.radius , geo.center.z - geo.radius, 1), vec4(diameter, diameter, diameter, 0));
}

AABB expandAABBWithGeometry(const AABB aabb, const Geometry geo) {
	AABB geometryAABB = generateFromGeometry(geo);
	return joinAABBs(aabb, geometryAABB);
}

/*=======================================================================================================
  ===                                    BVH-Tree Structures                                          ===
  =======================================================================================================*/

/**
 * This represents a node of BVH-tree for an Acceleration Structure used in raytracing.
 */
struct NodeData {
	/**
	 * The node AABB that can be either:
	 *     - The content AABB if the current node is a leaf
	 *     - The union of left and right AABBs
	 */
	AABB aabb;
};

struct BLAS {
	mat4 ModelMatrix;

	NodeData tree[numberOfTreeElementsToContainExpOfTwoLeafs( expOfTwo_numberOfLeafsOnBLAS )];
};

struct TLAS {
	NodeData tree[numberOfTreeElementsToContainExpOfTwoLeafs( expOfTwo_maxModels )];
};

/**
 * Check if the BLAS node at the given index is a leaf.
 *
 * @param index the node index on the linearized BVH-tree
 * @return TRUE iif the node is a leaf
 */
bool isBLASNodeLeaf_ByIndex(const uint leafIndex) {
	return leafIndex > (1 << expOfTwo_numberOfLeafsOnBLAS) - 1;
}

/**
 * Check if the TLAS node at the given index is a leaf.
 *
 * @param index the node index on the linearized BVH-tree
 * @return TRUE iif the node is a leaf
 */
bool isTLASNodeLeaf_ByIndex(const uint leafIndex) {
	return leafIndex >= (1 << expOfTwo_maxModels) - 1;
}


/*=======================================================================================================
  ===                                  Core SSBOs & Related Data                                      ===
  =======================================================================================================*/

struct GeometryCollection {
	Geometry geometry[1 << expOfTwo_maxGeometryOnCollection];
};

struct BLASGeometryCollection {
	GeometryCollection collection[1 << expOfTwo_maxCollectionsForModel];
};

layout(std430, binding = 0) buffer sceneGeometry {
	BLASGeometryCollection geometry[]; // This is an array of geometry
};

layout(std430, binding = 1) buffer sceneBLAS {
	BLAS tlasBLAS[]; // This is the BLAS collection
};

layout(std430, binding = 2) buffer sceneTLAS {
	TLAS tlas; // This is the BLAS collection
};

bool isEmptyBLAS_ByIndex(uint index) {
	return tlasBLAS[index].ModelMatrix == emptyTransform;
}

#if defined(BVH_INSERT)
/*=======================================================================================================
  ===                                  BVH-Tree Construction                                          ===
  =======================================================================================================*/

struct InputGeometry {
	vec4 centroid_radius;
};

struct InputGeometryCollection {
	InputGeometry inputCollection[1 << expOfTwo_maxCollectionsForModel];
};

Geometry transformToGPURepresentation(const InputGeometry inGeometry) {
	Geometry outGeometry = Geometry(vec4(inGeometry.centroid_radius.xyz, 1), inGeometry.centroid_radius.w);

	return outGeometry;
}

layout(std430, binding = 3) buffer insertionGeometry {
	uint targetBLAS; // The index of the BLAS to be updated (rewritted if occupied)
	uint numberOfGeometryToInsert; // Number of geometric primitives to be inserted
	InputGeometryCollection geometryToInsert[]; // This is the collection of geometry to be organized on the BLAS
};

layout(std430, binding = 4) buffer insertionGeometryMorton {
	uint mortonCode[]; // This is the BLAS collection
};

// Expands a 10-bit integer into 30 bits
// by inserting 2 zeros after each bit.
uint expandBits(uint v)
{
    v = (v * 0x00010001u) & 0xFF0000FFu;
    v = (v * 0x00000101u) & 0x0F00F00Fu;
    v = (v * 0x00000011u) & 0xC30C30C3u;
    v = (v * 0x00000005u) & 0x49249249u;
    return v;
}

/**
 * Calculates a 30-bit Morton code for the given 3D point located within the unit cube [0,1].
 */
uint morton3D(const vec3 point)
{
    const float x = min(max(point.x * 1024.0f, 0.0f), 1023.0f);
    const float y = min(max(point.y * 1024.0f, 0.0f), 1023.0f);
    const float z = min(max(point.z * 1024.0f, 0.0f), 1023.0f);
    const uint xx = expandBits(uint(point.x));
    const uint yy = expandBits(uint(point.y));
    const uint zz = expandBits(uint(point.z));
    return xx * 4 + yy * 2 + zz;
}

AABB generateAABBFromGeometryOnBLASLeaf_ByBaseIndexOnGeometry(const uint BLASIndex, const uint CollectionIndex) {
	AABB bounding = emptyAABB;

	for (uint i = 0; i < (1 << expOfTwo_maxGeometryOnCollection); ++i) {
		bounding = expandAABBWithGeometry(bounding, geometry[BLASIndex].collection[CollectionIndex].geometry[i]);
	}

	return bounding;
}

layout(local_size_x = 48, local_size_y = 32, local_size_z = 1) in;

/**
 * This is the entry point for the geometry insertion program.
 * The basic idea is that we want to insert the geometry on the final position
 * (gl_GlobalInvocationID.y * (1 << expOfTwo_maxGeometryOnCollection)) + gl_GlobalInvocationID.x
 * and then build the tree back to the root.
 * 
 * Usage: the compute shader MUST be dispatched as glDispatchCompute(maxNumOfGeometry / numOfGeometryPerCollection, numOfGeometryCollectionsPerBLAS, 1),
 *        also the geometry must be aligned with mortoncodes such as mortonCode[i] is the morton code of the geometry at geometry[i]
 */
void main() {
	if ((gl_GlobalInvocationID.y >= (1 << expOfTwo_maxCollectionsForModel)) || (gl_GlobalInvocationID.x >= (1 << expOfTwo_maxGeometryOnCollection))) return;

	// Copy the geometry on the final destination.
	geometry[targetBLAS].collection[gl_GlobalInvocationID.y].geometry[gl_GlobalInvocationID.x] = transformToGPURepresentation(geometryToInsert[gl_GlobalInvocationID.y].inputCollection[gl_GlobalInvocationID.x]);

	// Where "(1 << expOfTwo_maxCollectionsForModel) - 1" is used to reach the first valid leaf on the BLAS tree
	uint indexOfNodeInBLASToUpdate = ((1 << expOfTwo_maxCollectionsForModel) - 1) + gl_GlobalInvocationID.y;
	
	/*
	barrier();
	// the geometry has been updated
	if (gl_GlobalInvocationID.x != 0) return;
	*/

	bool rootUpdated = false;
	while (!rootUpdated) {
		tlasBLAS[targetBLAS].tree[indexOfNodeInBLASToUpdate].aabb = (isBLASNodeLeaf_ByIndex(indexOfNodeInBLASToUpdate))
			? generateAABBFromGeometryOnBLASLeaf_ByBaseIndexOnGeometry(targetBLAS, gl_GlobalInvocationID.y)
			: joinAABBs(tlasBLAS[targetBLAS].tree[leftNode(indexOfNodeInBLASToUpdate)].aabb, tlasBLAS[targetBLAS].tree[rightNode(indexOfNodeInBLASToUpdate)].aabb);

		rootUpdated = isRootNode(indexOfNodeInBLASToUpdate);

		// Get to the parent for the next iteration
		indexOfNodeInBLASToUpdate = parentNode(indexOfNodeInBLASToUpdate);
	}

	// At the very end, flag the BLAS as used/occupied
	tlasBLAS[targetBLAS].ModelMatrix = identityTransform;

	uint indexOfNodeInTLAS = ((1 << expOfTwo_maxModels) - 1) + targetBLAS;

	rootUpdated = false;
	while (!rootUpdated) {
		tlas.tree[indexOfNodeInTLAS].aabb = (isTLASNodeLeaf_ByIndex(indexOfNodeInBLASToUpdate))
			? tlasBLAS[targetBLAS].tree[0].aabb
			: joinAABBs(
				tlas.tree[leftNode(indexOfNodeInTLAS)].aabb,
				tlas.tree[rightNode(indexOfNodeInTLAS)].aabb);

		rootUpdated = isRootNode(indexOfNodeInTLAS);
		
		// Get to the parent for the next iteration
		indexOfNodeInTLAS = parentNode(indexOfNodeInTLAS);
	}
}

#elif defined(TLAS_FLUSH)

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

/**
 * This is the entry point for the TLAS nuke program.
 * The basic idea is that we want to empty all geometry and then (re-)build the tree back to the root.
 *
 * Usage: the compute shader MUST be dispatched as glDispatchCompute(maxModels, 1, 1).
 */
void main() {
	if ((gl_GlobalInvocationID.x >= (1 << expOfTwo_maxModels)) || (gl_GlobalInvocationID.y != 0)) return;

	tlasBLAS[gl_GlobalInvocationID.x].ModelMatrix = emptyTransform;

	uint indexOfNodeInTLAS = ((1 << expOfTwo_maxModels) - 1) + gl_GlobalInvocationID.x;

	bool rootUpdated = false;
	while (!rootUpdated) {
		tlas.tree[indexOfNodeInTLAS].aabb = emptyAABB;

		rootUpdated = isRootNode(indexOfNodeInTLAS);
		
		if (isEven(indexOfNodeInTLAS)) break;

		// Get to the parent for the next iteration
		indexOfNodeInTLAS = parentNode(indexOfNodeInTLAS);
	}

}

#endif