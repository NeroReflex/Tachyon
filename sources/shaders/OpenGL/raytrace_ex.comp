#version 450 core

#define expOfTwoOfMaxGeometryElementsInCollection 3
#define expOfTwoOfMaxCollectionElementsInBLAS 5

const float PI = 3.14159265359;
const float infinity = (1.0) / 0.0;
const float minusInfinity = (-1.0) / 0.0;
const mat4 identityTransform = mat4(1);

layout(local_size_x = 48, local_size_y = 32, local_size_z = 1) in;

struct Geometry {
	vec4 signature;
	vec4 vertex1_or_sphere_center;
	vec4 vertex2_or_sphere_radius;
	vec4 vertex3_or_nothing;
};

struct GeometryCollection {
	/**
	 * This is the collection of indices of referenced geometry.
	 *
	 * The number of referenced geometry is the number of elements not equal to an empty geometry.
	 */
	uint geometryIndex[1 << expOfTwoOfMaxGeometryElementsInCollection];
};

/**
 * This represents an Axis-Aligned Bounding Box.
 *
 *    +--------------+ < Max vertex (max x, y and z amongs all vertices)
 *   /|             /|
 *  / |            / |
 * *--+-----------*  |
 * |  |           |  | Depth
 * |  |           |  |
 * |  |           |  |
 * |  +-----------+--+
 * | /            | /
 * |/             |/ Width
 * *--------------*
 * ^    Length
 * Position vertex (minimum x, y and z amongs all vertices)
 */
struct AABB {
	/**
	 * This is the position vertex of the AABB.
	 *
	 * The used format is vec4(x, y, z, 1)
	 */
	vec4 position; // this is the point of the aabb with min x, y and z components
	
	/**
	 * This is the collection of AABB dimensions.
	 *
	 * The used format is vec4(Length, Depth, Width, 0)
	 * Note: fastest way to find the max vertex of the AABB: position+dimensions
	 */
	vec4 dimensions; // this is the amount to be added to aabbVertex to obtain the point with max x, y and z in the aabb
};

struct NodeData {
	AABB aabb;
	uint left; // this can also be the content if right is zero
	uint right; // this is zero if the node is a leaf
};

struct BLAS {
	GeometryCollection collection[1 << expOfTwoOfMaxCollectionElementsInBLAS];
	
	NodeData tree[((1 << expOfTwoOfMaxCollectionElementsInBLAS) * 2) - 1];
};

layout(std430, binding = 0) buffer sceneBLAS {
	BLAS tlasBLAS[]; // This is the BLAS collection
};

layout(std430, binding = 1) buffer sceneTree {
	NodeData tlasTree[]; // This is the TLAS tree that reference the whole BLAS collection
};

layout(std430, binding = 2) buffer sceneModelMatrix {
	mat4 blasModelMatrix[]; // This is the ModelMatrix collection for BLAS, given an index i ModelMatrix[i] is the model matrix of the object represented by tlasBLAS[i]
};

layout(std430, binding = 3) buffer sceneGeometry {
	Geometry globalGeometry[];
};

layout(rgba32f, binding = 0) uniform image2D img_output; // Raytracing output texture

layout(location = 0) uniform vec3 mOrigin;
layout(location = 1) uniform vec3 mLowerLeftCorner;
layout(location = 2) uniform vec3 mHorizontal;
layout(location = 3) uniform vec3 mVertical;

layout(location = 4) uniform mat4 tlasViewMatrix;

layout(location = 5) uniform uint width; // Render target surface width
layout(location = 6) uniform uint height; // Render target surface height

/*************************************************************************************************************************
 *                                                  Algorithms                                                           *
 *************************************************************************************************************************/

/**
 * Given a node of a binary tree with a fixed structure with index i,
 * returns true if the node is the root of the entire structure.
 * 
 * @param i the node index on the tree-array
 * @return TRUE iif the index is the root of the tree-array
 */
bool isRootNode(uint i) {
	return i == 0;
}

/**
 * Given a node of a binary tree with a fixed structure with index i,
 * returns the index of its parent node in the same fixed structure.
 *
 * @param i the node index on the tree-array
 * @return the parent node index on the tree-array 
 */
uint parentNode(uint i) {
	return (i - 1) / 2;
}

/**
 * Given a node of a binary tree with a fixed structure with index i,
 * returns the index of its left childer node in the same fixed structure.
 *
 * @param i the node index on the tree-array
 * @return the left childern node index on the tree-array 
 */
uint leftNode(uint i) {
	return (2 * i + 1);
}

/**
 * Given a node of a binary tree with a fixed structure with index i,
 * returns the index of its right childer node in the same fixed structure.
 *
 * @param i the node index on the tree-array
 * @return the right childern node index on the tree-array 
 */
uint rightNode(uint i) {
	return (2 * i + 2);
}

struct RayGeometryIntersection {
	float dist;
	vec4 point;
	vec4 normal;
};

struct Ray {
	vec4 origin;
	vec4 direction;
};

// Empty geometry is a sphere with radius equals to 0.0 such geometry CANNOT be intersected
const Geometry emptyGeometry = Geometry(
	vec4(0, 0, 0, 0),
	vec4(0, 0, 0, 0),
	vec4(0, 0, 0, 0),
	vec4(0, 0, 0, 0)
);

const RayGeometryIntersection miss = RayGeometryIntersection(infinity, vec4(0, 0, 0, 1), vec4(0, 0, 0, 0));

RayGeometryIntersection bestHit(const RayGeometryIntersection isect1, const RayGeometryIntersection isect2) {
	return (isect1.dist < isect2.dist) ? isect1 : isect2;
}

bool isLeaf(const NodeData node) {
	return node.right == 0;
}

bool hasMissed(const RayGeometryIntersection test) {
	return isinf(test.dist) || isnan(test.dist);
}

vec3 rayPointAt(const Ray ray, const float coeff) {
	return vec3(ray.origin) + coeff * vec3(ray.direction);
}

vec3 getInvDirection(const Ray ray) {
	return 1.0/ray.direction.xyz;
}

float getArea(AABB aabb) {
	return 2 * ((aabb.dimensions.x * aabb.dimensions.z) + (aabb.dimensions.x * aabb.dimensions.y) + (aabb.dimensions.y * aabb.dimensions.z));
}

/**
 * Apply a transform to the given AABB.
 *
 * @param starting the AABB transformation will be applied to
 * @param transformMatrix the transform to be applied to all vertices of the AABB, given as a 4x4 matrix
 * @return thetransformed AABB
 */
AABB transformAABB(const AABB starting, const mat4 transformMatrix) {
	vec4 v[8] = {
		transformMatrix * vec4(starting.position.x, starting.position.y, starting.position.z, 1),
		transformMatrix * vec4(starting.position.x, starting.position.y, starting.position.z + starting.dimensions.z, 1),
		transformMatrix * vec4(starting.position.x, starting.position.y + starting.dimensions.y, starting.position.z, 1),
		transformMatrix * vec4(starting.position.x, starting.position.y + starting.dimensions.y, starting.position.z + starting.dimensions.z, 1),
		transformMatrix * vec4(starting.position.x + starting.dimensions.x, starting.position.y, starting.position.z, 1),
		transformMatrix * vec4(starting.position.x + starting.dimensions.x, starting.position.y, starting.position.z + starting.dimensions.z, 1),
		transformMatrix * vec4(starting.position.x + starting.dimensions.x, starting.position.y + starting.dimensions.y, starting.position.z, 1),
		transformMatrix * vec4(starting.position.x + starting.dimensions.x, starting.position.y + starting.dimensions.y, starting.position.z + starting.dimensions.z, 1),
	};

	float maxX = minusInfinity, maxY = minusInfinity, maxZ=minusInfinity, minX=infinity, minY=infinity, minZ=infinity;

	for (uint i = 0; i < 8; ++i) {
		maxX = (v[i].x > maxX) ? v[i].x : maxX;
		maxY = (v[i].y > maxY) ? v[i].y : maxY;
		maxZ = (v[i].z > maxZ) ? v[i].z : maxZ;
		minX = (v[i].x < minX) ? v[i].x : minX;
		minY = (v[i].y < minY) ? v[i].y : minY;
		minZ = (v[i].z < minZ) ? v[i].z : minZ;
	}

	return AABB(vec4(minX, minY, minZ, 1), vec4(maxX-minX, maxY-minY, maxZ-minZ, 0));
}

bool intersectAABB(const Ray ray, const AABB aabb, const mat4 transformMatrix) {
	AABB transformedAABB = transformAABB(aabb, transformMatrix);

	float tmin, tmax, tymin, tymax, tzmin, tzmax;

	vec3 orig = ray.origin.xyz;
	vec3 invdir = getInvDirection(ray);

	vec3 bounds[2] = {
		transformedAABB.position.xyz,
		(transformedAABB.position.xyz) + (transformedAABB.dimensions.xyz)
	};

	const int[3] raySigns = int[3](
		(invdir.x < 0) ? 1 : 0,
		(invdir.y < 0) ? 1 : 0,
		(invdir.z < 0) ? 1 : 0
	);

	tmin = (bounds[raySigns[0]].x - orig.x) * invdir.x;
	tmax = (bounds[1 - raySigns[0]].x - orig.x) * invdir.x;
	tymin = (bounds[raySigns[1]].y - orig.y) * invdir.y;
	tymax = (bounds[1 - raySigns[1]].y - orig.y) * invdir.y;

	if ((tmin > tymax) || (tymin > tmax))
		return false;
	if (tymin > tmin)
		tmin = tymin;
	if (tymax < tmax)
		tmax = tymax;

	tzmin = (bounds[raySigns[2]].z - orig.z) * invdir.z;
	tzmax = (bounds[1 - raySigns[2]].z - orig.z) * invdir.z;

	if ((tmin > tzmax) || (tzmin > tmax))
		return false;
	if (tzmin > tmin)
		tmin = tzmin;
	if (tzmax < tmax)
		tmax = tzmax;

	return true;
}

RayGeometryIntersection intersectGeometry(const Ray ray, const Geometry geometry, const mat4 transformMatrix, const float minDistance, const float maxDistance) {
	if (geometry.signature.w == 0.0) { // test ray-sphere intersection
		const vec3 center = vec3(transformMatrix * geometry.vertex1_or_sphere_center);
		const float radius = geometry.vertex2_or_sphere_radius.x;

		if (radius == 0) return miss;

		const vec3 origin = vec3(ray.origin);
		const vec3 direction = vec3(ray.direction);

		vec3 oc = origin - center;
	
		const float a = dot(direction, direction);
		const float b = dot(oc, direction);
		const float c = dot(oc, oc) - radius * radius;
		const float discriminant = b * b - a * c;

		if (discriminant > 0.0) { // if delta > 0 then we have two intersections (one for each side of the sphere)
			const float squareRoot = sqrt(discriminant);

			// x0 and x1 are the distances to the origin of the ray
			float x0 = (-b - squareRoot) / a, x1 = (-b + squareRoot) / a;

			// Use x0 and x1 to calculate intersection points
			vec3 point_x0 = rayPointAt(ray, x0), point_x1 = rayPointAt(ray, x1); // so if I use that distance as a coefficient I obtain the intersection point
		
			// Use intersecting points to calculate the surface normal at that point
			vec3 normal_x0 = (point_x0 - center) / radius, normal_x1 = (point_x1 - center) / radius; // and the normal for a point p is (point - center)/radius

			// No valid intersection? return a miss.
			if (((x0 <= minDistance) || (x0 >= maxDistance)) && ((x1 <= minDistance) || (x1 >= maxDistance))) {
				return miss;
			}

			// Choose the closest intersection point
			return (((x0 > minDistance) && (x0 < maxDistance)) && (x0 <= x1)) || ((x1 <= minDistance) || (x1 >= maxDistance)) ?
				RayGeometryIntersection(x0, vec4(point_x0, 1), vec4(normal_x0, 0)) : RayGeometryIntersection(x1, vec4(point_x1, 1), vec4(normal_x1, 0));
		}
	} else if (geometry.signature.w == 1.0) { // test ray-triangle intersection

	}

	return miss;
}

RayGeometryIntersection intersectCollection(const Ray ray, const GeometryCollection collection, const mat4 transformMatrix, const float minDistance, const float maxDistance) {
	RayGeometryIntersection bestHitSoFar = miss;

	for (uint i = 0; i < (1 << expOfTwoOfMaxGeometryElementsInCollection) ; ++i) {
		// Execute the ray-geometry intersection algorithm
		const RayGeometryIntersection currentIntersectionInfo = intersectGeometry(ray, globalGeometry[collection.geometryIndex[i]], transformMatrix, minDistance, maxDistance);

		// Check if this is a better hit than the former one
		bestHitSoFar = bestHit(bestHitSoFar, currentIntersectionInfo);
	}

	return bestHitSoFar;
}

RayGeometryIntersection intersectBLAS_ByIndex(const Ray ray, const uint blasIndex, const mat4 ViewMatrix, const float minDistance, const float maxDistance) {
	// Adjust transformation matrix to consider the BLAS model matrix
	mat4 transformMatrix = ViewMatrix * blasModelMatrix[blasIndex];

	RayGeometryIntersection bestHitSoFar = miss;

	int currentDepth = 0;
	uint currentPath = 0;

	while ((currentDepth < 32) && (currentDepth >= 0)) {
		uint currentNodeIndex = 0;

		// This for cycles is used to reach the interesting node
		for (uint i = 0; i < currentDepth; ++i) {
			currentNodeIndex = ((currentPath & (1 << currentDepth)) == 0) ? tlasBLAS[blasIndex].tree[currentNodeIndex].left : tlasBLAS[blasIndex].tree[currentNodeIndex].left;
		}

		if ((!isLeaf(tlasBLAS[blasIndex].tree[currentNodeIndex])) && (intersectAABB(ray, tlasBLAS[blasIndex].tree[currentNodeIndex].aabb, transformMatrix))) {
			// Go one level deeper
			currentDepth += 1;
		} else {
			// This is a leaf that should be tested...
			if ((isLeaf(tlasBLAS[blasIndex].tree[currentNodeIndex])) && (intersectAABB(ray, tlasBLAS[blasIndex].tree[currentNodeIndex].aabb, transformMatrix))) {
				RayGeometryIntersection currentHit = intersectCollection(ray, tlasBLAS[blasIndex].collection[tlasBLAS[blasIndex].tree[currentNodeIndex].left], transformMatrix, minDistance, maxDistance);

				bestHitSoFar = bestHit(bestHitSoFar, currentHit);
			}

			// in either case: subtree discarded or visited leaf the algorithm should reduce the depth and change the path
			currentDepth -= 1;

			while (((currentPath & (1 << currentDepth)) == 1) && (currentDepth >= 0)) {
				//set the bit at currentDepth position to 0
				currentPath &= ~(1 << currentDepth);

				// and decrease currentDepth
				currentDepth -= 1;
			}

			if (currentDepth >= 0) {
				// set the bit at currentDepth position to 1 (the next visit will choose another path)
				currentPath |= (1 << currentDepth);
			} else {
				// the visited node was the very last one (the right-most) and the iteration should come to an end
				break;
			}
		}
	}

	return bestHitSoFar;
}

RayGeometryIntersection castRay(const Ray ray, const mat4 transformMatrix, const float minDistance, const float maxDistance) {
	RayGeometryIntersection bestHitSoFar = miss;

	int currentDepth = 0;
	uint currentPath = 0;

	while ((currentDepth < 32) && (currentDepth >= 0)) {
		uint currentNodeIndex = 0;

		// This for cycles is used to reach the interesting node
		for (uint i = 0; i < currentDepth; ++i) {
			currentNodeIndex = ((currentPath & (1 << currentDepth)) == 0) ? tlasTree[currentNodeIndex].left : tlasTree[currentNodeIndex].left;
		}

		if ((!isLeaf(tlasTree[currentNodeIndex])) && (intersectAABB(ray, tlasTree[currentNodeIndex].aabb, transformMatrix))) {
			// Go one level deeper
			currentDepth += 1;
		} else {
			// This is a leaf that should be tested...
			if ((isLeaf(tlasTree[currentNodeIndex])) && (intersectAABB(ray, tlasTree[currentNodeIndex].aabb, transformMatrix))) {
				RayGeometryIntersection currentHit = intersectBLAS_ByIndex(ray, tlasTree[currentNodeIndex].left, transformMatrix, minDistance, maxDistance);

				bestHitSoFar = bestHit(bestHitSoFar, currentHit);
			}

			// in either case: subtree discarded or visited leaf the algorithm should reduce the depth and change the path
			currentDepth -= 1;

			while (((currentPath & (1 << currentDepth)) == 1) && (currentDepth >= 0)) {
				//set the bit at currentDepth position to 0
				currentPath &= ~(1 << currentDepth);

				// and decrease currentDepth
				currentDepth -= 1;
			}

			if (currentDepth >= 0) {
				// set the bit at currentDepth position to 1 (the next visit will choose another path)
				currentPath |= (1 << currentDepth);
			} else {
				// the visited node was the very last one (the right-most) and the iteration should come to an end
				break;
			}
		}
	}

	return bestHitSoFar;
}

Ray generateCameraRay(float s, float t) {
	return Ray(vec4(mOrigin, 1), vec4(mLowerLeftCorner + s * mHorizontal + t * mVertical - mOrigin, 0));
}

void renderHitOrMiss() {
	// base pixel colour for image
	vec4 pixel = vec4(0, 0, 0, 0);
	// get index in global work group i.e x,y position
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

	// Avoid calculating useless pixels
	if ((gl_GlobalInvocationID.x >= width) || (gl_GlobalInvocationID.y >= height)) {
		return;
	}
	
	// Get UV cordinates of the output texture
	const float u = float(gl_GlobalInvocationID.x) / float(width);
	const float v = float(gl_GlobalInvocationID.y) / float(height);

	// Generate camera ray
	Ray cameraRay = generateCameraRay(u, v);

	pixel = vec4(hasMissed(castRay(cameraRay, tlasViewMatrix, 0.001, 1000.0)) ? vec3(0,0,0) : vec3(1,1,1), 1.0);
  
	// output to a specific pixel in the image
	imageStore(img_output, pixel_coords, pixel);
}

void renderDistanceShading() {
	// base pixel colour for image
	vec4 pixel = vec4(0, 0, 0, 0);
	// get index in global work group i.e x,y position
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

	// Avoid calculating useless pixels
	if ((gl_GlobalInvocationID.x >= width) || (gl_GlobalInvocationID.y >= height)) {
		return;
	}
	
	// Get UV cordinates of the output texture
	const float u = float(gl_GlobalInvocationID.x) / float(width);
	const float v = float(gl_GlobalInvocationID.y) / float(height);

	// Generate camera ray
	Ray cameraRay = generateCameraRay(u, v);

	RayGeometryIntersection isect = castRay(cameraRay, tlasViewMatrix, 0.001, 1000.0);

	pixel = vec4( vec3(max(0, dot(isect.normal, normalize(/*mPosition*/ -isect.point)))) , 1.0);
  
	// output to a specific pixel in the image
	imageStore(img_output, pixel_coords, pixel);
}


// This is here to avoid errors from glslangValidator
void main() {
	renderDistanceShading();
}
