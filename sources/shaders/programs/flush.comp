#version 450 core

#include "../config.glsl"
#include "../utils.glsl"
#include "../ray.glsl"
#include "../camera.glsl"
#include "../geometry.glsl"
#include "../aabb.glsl"
#include "../bvh.glsl"
#include "../core.glsl"
#include "../intersection.glsl"

layout(local_size_x = FLUSH_WORKGROUP_X, local_size_y = 1, local_size_z = 1) in;

/**
 * This is the entry point for the TLAS nuke program.
 * The basic idea is that we want to empty all geometry and then (re-)build the tree back to the root.
 *
 * Usage: the compute shader MUST be dispatched as glDispatchCompute(maxModels, 1, 1).
 */
void main() {
	// An instance of this compute shader will reset the BLAS at index gl_GlobalInvocationID.x
	if ((gl_GlobalInvocationID.x < (1 << expOfTwo_maxModels)) && (gl_GlobalInvocationID.y == 0) && (gl_GlobalInvocationID.z == 0)) {
		const uint indexOfBLASToNuke = gl_GlobalInvocationID.x;

		WriteModelMatrix_ByIndex(indexOfBLASToNuke, emptyTransform);

		uint indexOfNodeInTLAS = NodeFromTLASLeaf_ByLeafNumber(indexOfBLASToNuke);

		WriteAABBOnTLAS_ByIndex(indexOfNodeInTLAS, emptyAABB);

		// This update the TLAS from a leaf to its root
		while (!isRootNode(indexOfNodeInTLAS)) {
			memoryBarrierBuffer();

			indexOfNodeInTLAS = parentNode(indexOfNodeInTLAS);

			WriteAABBOnTLAS_ByIndex(indexOfNodeInTLAS, emptyAABB);
		}

		// This nukes the entire BLAS
		for (uint blasLinearNode = 0; blasLinearNode < (numberOfTreeElementsToContainExpOfTwoLeafs(expOfTwo_maxModels)); ++blasLinearNode) {
			WriteAABBOnBLAS_ByIndexes(indexOfBLASToNuke, blasLinearNode, emptyAABB);

			memoryBarrierBuffer();
		}

		for (uint geometryCollectionIndex = 0; geometryCollectionIndex < (1 << expOfTwo_maxCollectionsForModel); ++geometryCollectionIndex) {
			for (uint geometryIndex = 0; geometryIndex < (1 << expOfTwo_maxGeometryOnCollection); ++geometryIndex) {
				WriteGeometry_ByIndexes(indexOfBLASToNuke, geometryCollectionIndex, geometryIndex, emptyGeometry);

				memoryBarrierBuffer();
			}
		}

	}
}