#version 450 core

#include "../config.glsl"
#include "../utils.glsl"
#include "../ray.glsl"
#include "../camera.glsl"
#include "../geometry.glsl"
#include "../aabb.glsl"
#include "../bvh.glsl"
#include "../core.glsl"
#include "../intersection.glsl"

layout(local_size_x = RENDER_WORKGROUP_X, local_size_y = RENDER_WORKGROUP_Y, local_size_z = RENDER_WORKGROUP_Z) in;

layout(rgba32f, binding = DEBUG_BINDING) uniform writeonly image2D debugOutput;

layout(rgba32f, binding = OUTPUT_BINDING) uniform writeonly image2D renderTarget; // Raytracing output texture

layout (std140, binding = HDR_BINDING) uniform hdr {
	float gamma;
	float exposure;
};

layout (std140, binding = CAMERA_BINDING) uniform cameraData {
	vec3 cameraPosition;
	vec3 cameraViewDir;
	vec3 cameraUpVector;
	float cameraFoV;
	float cameraAspect;

	vec3 cameraLowerLeftCorner;
	vec3 cameraHorizontal;
	vec3 cameraVertical;
};

/**
 * This is the entry point for the rendering program.
 *
 * Usage: the compute shader MUST be dispatched as glDispatchCompute(width, height, 1).
 */
void main() {
	ivec2 renderTargetSize = imageSize(renderTarget);

	// Avoid calculating useless pixels
	if ((gl_GlobalInvocationID.x >= renderTargetSize.x) || (gl_GlobalInvocationID.y >= renderTargetSize.y)) return;

	// base pixel color for image
	vec4 pixel = vec4(0, 0, 0, 0);

	// get index in global work group i.e x,y position
	const ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

	// Get UV cordinates of the output texture
	const float u = float(gl_GlobalInvocationID.x) / float(renderTargetSize.x);
	const float v = float(gl_GlobalInvocationID.y) / float(renderTargetSize.y);

	// Generate camera
	const Camera camera = Camera(cameraPosition, cameraViewDir, cameraUpVector, cameraFoV, cameraAspect);

	// Generate camera ray
	//const Ray cameraRay = generateCameraRayFromCamera(camera, u, v);
	const Ray cameraRay = generateCameraRayFromScreenCoord(camera.lookFrom, cameraLowerLeftCorner, cameraHorizontal, cameraVertical, u, v);

	RayGeometryIntersection isect = castRay(cameraRay, 0.001, 1000.0); // Cast a ray on the TLAS and check for hit

	if (intersectAABB(cameraRay, ReadAABBFromBLAS_ByIndexes(0, 0), ReadModelMatrix_ByIndex(0))) {
		imageStore(debugOutput, pixel_coords, vec4(1, 0, 0, 1));
	} else {
		imageStore(debugOutput, pixel_coords, vec4(0, 0, 1, 1));
	}

	// Base pixel colour for image
	vec3 hdrColor = vec3(max(0, dot(isect.normal, normalize(vec4(camera.lookFrom, 0) - isect.point))));

	// Exposure tone mapping
	vec3 mapped = vec3(1.0) - exp(-hdrColor * exposure);

	// Apply gamma correction to the result
	pixel = vec4(pow(mapped, vec3(1.0 / gamma)), 1.0);

	// output to a specific pixel in the image
	imageStore(renderTarget, pixel_coords, pixel);
}