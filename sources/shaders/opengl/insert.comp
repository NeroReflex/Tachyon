#version 450 core

#include "../config.glsl"
#include "../utils.glsl"
#include "../ray.glsl"
#include "../camera.glsl"
#include "../geometry.glsl"
#include "../aabb.glsl"
#include "../bvh.glsl"
#include "../core.glsl"
#include "../intersection.glsl"

struct InputGeometry {
	vec4 centroid_radius;
};

vec3 getMortonPointFromInputGeometry(const in InputGeometry inGeom) {
	return inGeom.centroid_radius.xyz;
}

struct InputGeometryCollection {
	InputGeometry inputCollection[1 << expOfTwo_maxCollectionsForModel];
};

Geometry transformToGPURepresentation(const InputGeometry inGeometry) {
	Geometry outGeometry = Geometry(inGeometry.centroid_radius.xyz, inGeometry.centroid_radius.w);

	return outGeometry;
}

layout(location = 0) uniform uint targetBLAS;

layout(std430, binding = 3) buffer insertionGeometry {
	InputGeometryCollection geometryToInsert[]; // This is the collection of geometry to be organized on the BLAS
};

shared uint mortonCode[(1 << expOfTwo_maxCollectionsForModel) * (1 << expOfTwo_maxGeometryOnCollection)];

// Expands a 10-bit integer into 30 bits
// by inserting 2 zeros after each bit.
uint expandBits(uint v)
{
	v = (v * 0x00010001u) & 0xFF0000FFu;
	v = (v * 0x00000101u) & 0x0F00F00Fu;
	v = (v * 0x00000011u) & 0xC30C30C3u;
	v = (v * 0x00000005u) & 0x49249249u;
	return v;
}

/**
 * Calculates a 30-bit Morton code for the given 3D point located within the unit cube [0,1].
 */
uint morton3D(const in vec3 point)
{
	const float x = min(max(point.x * 1024.0f, 0.0f), 1023.0f);
	const float y = min(max(point.y * 1024.0f, 0.0f), 1023.0f);
	const float z = min(max(point.z * 1024.0f, 0.0f), 1023.0f);
	const uint xx = expandBits(uint(point.x));
	const uint yy = expandBits(uint(point.y));
	const uint zz = expandBits(uint(point.z));
	return xx * 4 + yy * 2 + zz;
}

layout(local_size_x = 32, local_size_y = 48, local_size_z = 1) in;

/**
 * This is the entry point for the geometry insertion program.
 * The basic idea is that we want to insert the geometry on the final position
 * (gl_GlobalInvocationID.y * (1 << expOfTwo_maxGeometryOnCollection)) + gl_GlobalInvocationID.x
 * and then build the tree back to the root.
 *
 * Usage: the compute shader MUST be dispatched as glDispatchCompute(numOfGeometryPerCollection, numOfGeometryCollectionsPerBLAS, 1),
 *        also the geometry must be aligned with mortoncodes such as mortonCode[i] is the morton code of the geometry at geometry[i]
 */
void main() {
	if ((gl_GlobalInvocationID.y >= (1 << expOfTwo_maxCollectionsForModel)) || (gl_GlobalInvocationID.x >= (1 << expOfTwo_maxGeometryOnCollection))) return;

	mortonCode[(gl_GlobalInvocationID.y * (1 << expOfTwo_maxGeometryOnCollection)) + gl_GlobalInvocationID.x] = morton3D(getMortonPointFromInputGeometry(geometryToInsert[gl_GlobalInvocationID.y].inputCollection[gl_GlobalInvocationID.x]));

	barrier(); // Ater this barrier all morton codes have been calculated and geometry is going to be sorted

	// Copy the geometry on the final destination.
	WriteGeometry_ByIndexes(
		targetBLAS,
		gl_GlobalInvocationID.y,
		gl_GlobalInvocationID.x,
		transformToGPURepresentation(geometryToInsert[gl_GlobalInvocationID.y].inputCollection[gl_GlobalInvocationID.x])
	);

	// Wait for all geometry to be in-place
	memoryBarrierImage();
	//barrier();

	// the geometry has been updated
	//if (gl_GlobalInvocationID.x != 0) return;

	uint indexOfNodeInBLASToUpdate = NodeFromBLASLeaf_ByLeafNumber(gl_GlobalInvocationID.y);
	WriteAABBOnBLAS_ByIndexes(targetBLAS, indexOfNodeInBLASToUpdate, generateAABBFromGeometryOnBLASLeaf_ByBaseIndexOnGeometry(targetBLAS, gl_GlobalInvocationID.y));

	while (!isRootNode(indexOfNodeInBLASToUpdate)) {
		memoryBarrierImage();

		indexOfNodeInBLASToUpdate = parentNode(indexOfNodeInBLASToUpdate);

		WriteAABBOnBLAS_ByIndexes(
			targetBLAS,
			indexOfNodeInBLASToUpdate,
			joinAABBs(
				ReadAABBFromBLAS_ByIndexes(targetBLAS, leftNode(indexOfNodeInBLASToUpdate)),
				ReadAABBFromBLAS_ByIndexes(targetBLAS, rightNode(indexOfNodeInBLASToUpdate))
			)
		);
	}

	// At the very end, flag the BLAS as used/occupied
	WriteModelMatrix_ByIndex(targetBLAS, identityTransform);

	// Perform a TLAS update after everything has been written on BLAS and geometry data collection
	barrier();
	if ((gl_GlobalInvocationID.x == 0) && (gl_GlobalInvocationID.y == 0) && (gl_GlobalInvocationID.z == 0)) {
		UpdateTLASFromLeafToRoot_ByIndex(targetBLAS);
	}
}